import {
  __commonJS
} from "./chunk-EWTE5DHJ.js";

// node_modules/africastalking-client/build/africastalking.js
var require_africastalking = __commonJS({
  "node_modules/africastalking-client/build/africastalking.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.Africastalking = t() : e.Africastalking = t();
    }(window, function() {
      return function(e) {
        var t = {};
        function r(n) {
          if (t[n]) return t[n].exports;
          var i = t[n] = { i: n, l: false, exports: {} };
          return e[n].call(i.exports, i, i.exports, r), i.l = true, i.exports;
        }
        return r.m = e, r.c = t, r.d = function(e2, t2, n) {
          r.o(e2, t2) || Object.defineProperty(e2, t2, { enumerable: true, get: n });
        }, r.r = function(e2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        }, r.t = function(e2, t2) {
          if (1 & t2 && (e2 = r(e2)), 8 & t2) return e2;
          if (4 & t2 && "object" == typeof e2 && e2 && e2.__esModule) return e2;
          var n = /* @__PURE__ */ Object.create(null);
          if (r.r(n), Object.defineProperty(n, "default", { enumerable: true, value: e2 }), 2 & t2 && "string" != typeof e2) for (var i in e2) r.d(n, i, (function(t3) {
            return e2[t3];
          }).bind(null, i));
          return n;
        }, r.n = function(e2) {
          var t2 = e2 && e2.__esModule ? function() {
            return e2.default;
          } : function() {
            return e2;
          };
          return r.d(t2, "a", t2), t2;
        }, r.o = function(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }, r.p = "", r(r.s = 3);
      }([function(e, t, r) {
        "use strict";
        (function(t2) {
          var n = r(6);
          e.exports = n({ window: t2.window });
        }).call(this, r(5));
      }, function(e, t, r) {
        "use strict";
        var n = true, i = true;
        function a(e2, t2, r2) {
          var n2 = e2.match(t2);
          return n2 && n2.length >= r2 && parseInt(n2[r2], 10);
        }
        e.exports = { extractVersion: a, wrapPeerConnectionEvent: function(e2, t2, r2) {
          if (e2.RTCPeerConnection) {
            var n2 = e2.RTCPeerConnection.prototype, i2 = n2.addEventListener;
            n2.addEventListener = function(e3, n3) {
              if (e3 !== t2) return i2.apply(this, arguments);
              var a3 = function(e4) {
                var t3 = r2(e4);
                t3 && n3(t3);
              };
              return this._eventMap = this._eventMap || {}, this._eventMap[n3] = a3, i2.apply(this, [e3, a3]);
            };
            var a2 = n2.removeEventListener;
            n2.removeEventListener = function(e3, r3) {
              if (e3 !== t2 || !this._eventMap || !this._eventMap[r3]) return a2.apply(this, arguments);
              var n3 = this._eventMap[r3];
              return delete this._eventMap[r3], a2.apply(this, [e3, n3]);
            }, Object.defineProperty(n2, "on" + t2, { get: function() {
              return this["_on" + t2];
            }, set: function(e3) {
              this["_on" + t2] && (this.removeEventListener(t2, this["_on" + t2]), delete this["_on" + t2]), e3 && this.addEventListener(t2, this["_on" + t2] = e3);
            }, enumerable: true, configurable: true });
          }
        }, disableLog: function(e2) {
          return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (n = e2, e2 ? "adapter.js logging disabled" : "adapter.js logging enabled");
        }, disableWarnings: function(e2) {
          return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (i = !e2, "adapter.js deprecation warnings " + (e2 ? "disabled" : "enabled"));
        }, log: function() {
          if ("object" == typeof window) {
            if (n) return;
            "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments);
          }
        }, deprecated: function(e2, t2) {
          i && console.warn(e2 + " is deprecated, please use " + t2 + " instead.");
        }, detectBrowser: function(e2) {
          var t2 = e2 && e2.navigator, r2 = { browser: null, version: null };
          if (void 0 === e2 || !e2.navigator) return r2.browser = "Not a browser.", r2;
          if (t2.mozGetUserMedia) r2.browser = "firefox", r2.version = a(t2.userAgent, /Firefox\/(\d+)\./, 1);
          else if (t2.webkitGetUserMedia) r2.browser = "chrome", r2.version = a(t2.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
          else if (t2.mediaDevices && t2.userAgent.match(/Edge\/(\d+).(\d+)$/)) r2.browser = "edge", r2.version = a(t2.userAgent, /Edge\/(\d+).(\d+)$/, 2);
          else {
            if (!e2.RTCPeerConnection || !t2.userAgent.match(/AppleWebKit\/(\d+)\./)) return r2.browser = "Not a supported browser.", r2;
            r2.browser = "safari", r2.version = a(t2.userAgent, /AppleWebKit\/(\d+)\./, 1);
          }
          return r2;
        } };
      }, function(e, t, r) {
        "use strict";
        var n = { generateIdentifier: function() {
          return Math.random().toString(36).substr(2, 10);
        } };
        n.localCName = n.generateIdentifier(), n.splitLines = function(e2) {
          return e2.trim().split("\n").map(function(e3) {
            return e3.trim();
          });
        }, n.splitSections = function(e2) {
          return e2.split("\nm=").map(function(e3, t2) {
            return (t2 > 0 ? "m=" + e3 : e3).trim() + "\r\n";
          });
        }, n.getDescription = function(e2) {
          var t2 = n.splitSections(e2);
          return t2 && t2[0];
        }, n.getMediaSections = function(e2) {
          var t2 = n.splitSections(e2);
          return t2.shift(), t2;
        }, n.matchPrefix = function(e2, t2) {
          return n.splitLines(e2).filter(function(e3) {
            return 0 === e3.indexOf(t2);
          });
        }, n.parseCandidate = function(e2) {
          for (var t2, r2 = { foundation: (t2 = 0 === e2.indexOf("a=candidate:") ? e2.substring(12).split(" ") : e2.substring(10).split(" "))[0], component: parseInt(t2[1], 10), protocol: t2[2].toLowerCase(), priority: parseInt(t2[3], 10), ip: t2[4], address: t2[4], port: parseInt(t2[5], 10), type: t2[7] }, n2 = 8; n2 < t2.length; n2 += 2) switch (t2[n2]) {
            case "raddr":
              r2.relatedAddress = t2[n2 + 1];
              break;
            case "rport":
              r2.relatedPort = parseInt(t2[n2 + 1], 10);
              break;
            case "tcptype":
              r2.tcpType = t2[n2 + 1];
              break;
            case "ufrag":
              r2.ufrag = t2[n2 + 1], r2.usernameFragment = t2[n2 + 1];
              break;
            default:
              r2[t2[n2]] = t2[n2 + 1];
          }
          return r2;
        }, n.writeCandidate = function(e2) {
          var t2 = [];
          t2.push(e2.foundation), t2.push(e2.component), t2.push(e2.protocol.toUpperCase()), t2.push(e2.priority), t2.push(e2.address || e2.ip), t2.push(e2.port);
          var r2 = e2.type;
          return t2.push("typ"), t2.push(r2), "host" !== r2 && e2.relatedAddress && e2.relatedPort && (t2.push("raddr"), t2.push(e2.relatedAddress), t2.push("rport"), t2.push(e2.relatedPort)), e2.tcpType && "tcp" === e2.protocol.toLowerCase() && (t2.push("tcptype"), t2.push(e2.tcpType)), (e2.usernameFragment || e2.ufrag) && (t2.push("ufrag"), t2.push(e2.usernameFragment || e2.ufrag)), "candidate:" + t2.join(" ");
        }, n.parseIceOptions = function(e2) {
          return e2.substr(14).split(" ");
        }, n.parseRtpMap = function(e2) {
          var t2 = e2.substr(9).split(" "), r2 = { payloadType: parseInt(t2.shift(), 10) };
          return t2 = t2[0].split("/"), r2.name = t2[0], r2.clockRate = parseInt(t2[1], 10), r2.channels = 3 === t2.length ? parseInt(t2[2], 10) : 1, r2.numChannels = r2.channels, r2;
        }, n.writeRtpMap = function(e2) {
          var t2 = e2.payloadType;
          void 0 !== e2.preferredPayloadType && (t2 = e2.preferredPayloadType);
          var r2 = e2.channels || e2.numChannels || 1;
          return "a=rtpmap:" + t2 + " " + e2.name + "/" + e2.clockRate + (1 !== r2 ? "/" + r2 : "") + "\r\n";
        }, n.parseExtmap = function(e2) {
          var t2 = e2.substr(9).split(" ");
          return { id: parseInt(t2[0], 10), direction: t2[0].indexOf("/") > 0 ? t2[0].split("/")[1] : "sendrecv", uri: t2[1] };
        }, n.writeExtmap = function(e2) {
          return "a=extmap:" + (e2.id || e2.preferredId) + (e2.direction && "sendrecv" !== e2.direction ? "/" + e2.direction : "") + " " + e2.uri + "\r\n";
        }, n.parseFmtp = function(e2) {
          for (var t2, r2 = {}, n2 = e2.substr(e2.indexOf(" ") + 1).split(";"), i = 0; i < n2.length; i++) r2[(t2 = n2[i].trim().split("="))[0].trim()] = t2[1];
          return r2;
        }, n.writeFmtp = function(e2) {
          var t2 = "", r2 = e2.payloadType;
          if (void 0 !== e2.preferredPayloadType && (r2 = e2.preferredPayloadType), e2.parameters && Object.keys(e2.parameters).length) {
            var n2 = [];
            Object.keys(e2.parameters).forEach(function(t3) {
              e2.parameters[t3] ? n2.push(t3 + "=" + e2.parameters[t3]) : n2.push(t3);
            }), t2 += "a=fmtp:" + r2 + " " + n2.join(";") + "\r\n";
          }
          return t2;
        }, n.parseRtcpFb = function(e2) {
          var t2 = e2.substr(e2.indexOf(" ") + 1).split(" ");
          return { type: t2.shift(), parameter: t2.join(" ") };
        }, n.writeRtcpFb = function(e2) {
          var t2 = "", r2 = e2.payloadType;
          return void 0 !== e2.preferredPayloadType && (r2 = e2.preferredPayloadType), e2.rtcpFeedback && e2.rtcpFeedback.length && e2.rtcpFeedback.forEach(function(e3) {
            t2 += "a=rtcp-fb:" + r2 + " " + e3.type + (e3.parameter && e3.parameter.length ? " " + e3.parameter : "") + "\r\n";
          }), t2;
        }, n.parseSsrcMedia = function(e2) {
          var t2 = e2.indexOf(" "), r2 = { ssrc: parseInt(e2.substr(7, t2 - 7), 10) }, n2 = e2.indexOf(":", t2);
          return n2 > -1 ? (r2.attribute = e2.substr(t2 + 1, n2 - t2 - 1), r2.value = e2.substr(n2 + 1)) : r2.attribute = e2.substr(t2 + 1), r2;
        }, n.parseSsrcGroup = function(e2) {
          var t2 = e2.substr(13).split(" ");
          return { semantics: t2.shift(), ssrcs: t2.map(function(e3) {
            return parseInt(e3, 10);
          }) };
        }, n.getMid = function(e2) {
          var t2 = n.matchPrefix(e2, "a=mid:")[0];
          if (t2) return t2.substr(6);
        }, n.parseFingerprint = function(e2) {
          var t2 = e2.substr(14).split(" ");
          return { algorithm: t2[0].toLowerCase(), value: t2[1] };
        }, n.getDtlsParameters = function(e2, t2) {
          return { role: "auto", fingerprints: n.matchPrefix(e2 + t2, "a=fingerprint:").map(n.parseFingerprint) };
        }, n.writeDtlsParameters = function(e2, t2) {
          var r2 = "a=setup:" + t2 + "\r\n";
          return e2.fingerprints.forEach(function(e3) {
            r2 += "a=fingerprint:" + e3.algorithm + " " + e3.value + "\r\n";
          }), r2;
        }, n.getIceParameters = function(e2, t2) {
          var r2 = n.splitLines(e2);
          return { usernameFragment: (r2 = r2.concat(n.splitLines(t2))).filter(function(e3) {
            return 0 === e3.indexOf("a=ice-ufrag:");
          })[0].substr(12), password: r2.filter(function(e3) {
            return 0 === e3.indexOf("a=ice-pwd:");
          })[0].substr(10) };
        }, n.writeIceParameters = function(e2) {
          return "a=ice-ufrag:" + e2.usernameFragment + "\r\na=ice-pwd:" + e2.password + "\r\n";
        }, n.parseRtpParameters = function(e2) {
          for (var t2 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r2 = n.splitLines(e2)[0].split(" "), i = 3; i < r2.length; i++) {
            var a = r2[i], o = n.matchPrefix(e2, "a=rtpmap:" + a + " ")[0];
            if (o) {
              var s = n.parseRtpMap(o), c = n.matchPrefix(e2, "a=fmtp:" + a + " ");
              switch (s.parameters = c.length ? n.parseFmtp(c[0]) : {}, s.rtcpFeedback = n.matchPrefix(e2, "a=rtcp-fb:" + a + " ").map(n.parseRtcpFb), t2.codecs.push(s), s.name.toUpperCase()) {
                case "RED":
                case "ULPFEC":
                  t2.fecMechanisms.push(s.name.toUpperCase());
              }
            }
          }
          return n.matchPrefix(e2, "a=extmap:").forEach(function(e3) {
            t2.headerExtensions.push(n.parseExtmap(e3));
          }), t2;
        }, n.writeRtpDescription = function(e2, t2) {
          var r2 = "";
          r2 += "m=" + e2 + " ", r2 += t2.codecs.length > 0 ? "9" : "0", r2 += " UDP/TLS/RTP/SAVPF ", r2 += t2.codecs.map(function(e3) {
            return void 0 !== e3.preferredPayloadType ? e3.preferredPayloadType : e3.payloadType;
          }).join(" ") + "\r\n", r2 += "c=IN IP4 0.0.0.0\r\n", r2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", t2.codecs.forEach(function(e3) {
            r2 += n.writeRtpMap(e3), r2 += n.writeFmtp(e3), r2 += n.writeRtcpFb(e3);
          });
          var i = 0;
          return t2.codecs.forEach(function(e3) {
            e3.maxptime > i && (i = e3.maxptime);
          }), i > 0 && (r2 += "a=maxptime:" + i + "\r\n"), r2 += "a=rtcp-mux\r\n", t2.headerExtensions && t2.headerExtensions.forEach(function(e3) {
            r2 += n.writeExtmap(e3);
          }), r2;
        }, n.parseRtpEncodingParameters = function(e2) {
          var t2, r2 = [], i = n.parseRtpParameters(e2), a = -1 !== i.fecMechanisms.indexOf("RED"), o = -1 !== i.fecMechanisms.indexOf("ULPFEC"), s = n.matchPrefix(e2, "a=ssrc:").map(function(e3) {
            return n.parseSsrcMedia(e3);
          }).filter(function(e3) {
            return "cname" === e3.attribute;
          }), c = s.length > 0 && s[0].ssrc, d = n.matchPrefix(e2, "a=ssrc-group:FID").map(function(e3) {
            return e3.substr(17).split(" ").map(function(e4) {
              return parseInt(e4, 10);
            });
          });
          d.length > 0 && d[0].length > 1 && d[0][0] === c && (t2 = d[0][1]), i.codecs.forEach(function(e3) {
            if ("RTX" === e3.name.toUpperCase() && e3.parameters.apt) {
              var n2 = { ssrc: c, codecPayloadType: parseInt(e3.parameters.apt, 10) };
              c && t2 && (n2.rtx = { ssrc: t2 }), r2.push(n2), a && ((n2 = JSON.parse(JSON.stringify(n2))).fec = { ssrc: c, mechanism: o ? "red+ulpfec" : "red" }, r2.push(n2));
            }
          }), 0 === r2.length && c && r2.push({ ssrc: c });
          var u = n.matchPrefix(e2, "b=");
          return u.length && (u = 0 === u[0].indexOf("b=TIAS:") ? parseInt(u[0].substr(7), 10) : 0 === u[0].indexOf("b=AS:") ? 1e3 * parseInt(u[0].substr(5), 10) * 0.95 - 16e3 : void 0, r2.forEach(function(e3) {
            e3.maxBitrate = u;
          })), r2;
        }, n.parseRtcpParameters = function(e2) {
          var t2 = {}, r2 = n.matchPrefix(e2, "a=ssrc:").map(function(e3) {
            return n.parseSsrcMedia(e3);
          }).filter(function(e3) {
            return "cname" === e3.attribute;
          })[0];
          r2 && (t2.cname = r2.value, t2.ssrc = r2.ssrc);
          var i = n.matchPrefix(e2, "a=rtcp-rsize");
          t2.reducedSize = i.length > 0, t2.compound = 0 === i.length;
          var a = n.matchPrefix(e2, "a=rtcp-mux");
          return t2.mux = a.length > 0, t2;
        }, n.parseMsid = function(e2) {
          var t2, r2 = n.matchPrefix(e2, "a=msid:");
          if (1 === r2.length) return { stream: (t2 = r2[0].substr(7).split(" "))[0], track: t2[1] };
          var i = n.matchPrefix(e2, "a=ssrc:").map(function(e3) {
            return n.parseSsrcMedia(e3);
          }).filter(function(e3) {
            return "msid" === e3.attribute;
          });
          return i.length > 0 ? { stream: (t2 = i[0].value.split(" "))[0], track: t2[1] } : void 0;
        }, n.generateSessionId = function() {
          return Math.random().toString().substr(2, 21);
        }, n.writeSessionBoilerplate = function(e2, t2, r2) {
          var i = void 0 !== t2 ? t2 : 2;
          return "v=0\r\no=" + (r2 || "thisisadapterortc") + " " + (e2 || n.generateSessionId()) + " " + i + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
        }, n.writeMediaSection = function(e2, t2, r2, i) {
          var a = n.writeRtpDescription(e2.kind, t2);
          if (a += n.writeIceParameters(e2.iceGatherer.getLocalParameters()), a += n.writeDtlsParameters(e2.dtlsTransport.getLocalParameters(), "offer" === r2 ? "actpass" : "active"), a += "a=mid:" + e2.mid + "\r\n", e2.direction ? a += "a=" + e2.direction + "\r\n" : e2.rtpSender && e2.rtpReceiver ? a += "a=sendrecv\r\n" : e2.rtpSender ? a += "a=sendonly\r\n" : e2.rtpReceiver ? a += "a=recvonly\r\n" : a += "a=inactive\r\n", e2.rtpSender) {
            var o = "msid:" + i.id + " " + e2.rtpSender.track.id + "\r\n";
            a += "a=" + o, a += "a=ssrc:" + e2.sendEncodingParameters[0].ssrc + " " + o, e2.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e2.sendEncodingParameters[0].rtx.ssrc + " " + o, a += "a=ssrc-group:FID " + e2.sendEncodingParameters[0].ssrc + " " + e2.sendEncodingParameters[0].rtx.ssrc + "\r\n");
          }
          return a += "a=ssrc:" + e2.sendEncodingParameters[0].ssrc + " cname:" + n.localCName + "\r\n", e2.rtpSender && e2.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e2.sendEncodingParameters[0].rtx.ssrc + " cname:" + n.localCName + "\r\n"), a;
        }, n.getDirection = function(e2, t2) {
          for (var r2 = n.splitLines(e2), i = 0; i < r2.length; i++) switch (r2[i]) {
            case "a=sendrecv":
            case "a=sendonly":
            case "a=recvonly":
            case "a=inactive":
              return r2[i].substr(2);
          }
          return t2 ? n.getDirection(t2) : "sendrecv";
        }, n.getKind = function(e2) {
          return n.splitLines(e2)[0].split(" ")[0].substr(2);
        }, n.isRejected = function(e2) {
          return "0" === e2.split(" ", 2)[1];
        }, n.parseMLine = function(e2) {
          var t2 = n.splitLines(e2)[0].substr(2).split(" ");
          return { kind: t2[0], port: parseInt(t2[1], 10), protocol: t2[2], fmt: t2.slice(3).join(" ") };
        }, n.parseOLine = function(e2) {
          var t2 = n.matchPrefix(e2, "o=")[0].substr(2).split(" ");
          return { username: t2[0], sessionId: t2[1], sessionVersion: parseInt(t2[2], 10), netType: t2[3], addressType: t2[4], address: t2[5] };
        }, n.isValidSDP = function(e2) {
          if ("string" != typeof e2 || 0 === e2.length) return false;
          for (var t2 = n.splitLines(e2), r2 = 0; r2 < t2.length; r2++) if (t2[r2].length < 2 || "=" !== t2[r2].charAt(1)) return false;
          return true;
        }, e.exports = n;
      }, function(e, t, r) {
        r(4), e.exports = r(17);
      }, function(e, t, r) {
        var n = function(e2) {
          "use strict";
          var t2 = Object.prototype, r2 = t2.hasOwnProperty, n2 = "function" == typeof Symbol ? Symbol : {}, i = n2.iterator || "@@iterator", a = n2.asyncIterator || "@@asyncIterator", o = n2.toStringTag || "@@toStringTag";
          function s(e3, t3, r3, n3) {
            var i2 = t3 && t3.prototype instanceof u ? t3 : u, a2 = Object.create(i2.prototype), o2 = new b(n3 || []);
            return a2._invoke = /* @__PURE__ */ function(e4, t4, r4) {
              var n4 = "suspendedStart";
              return function(i3, a3) {
                if ("executing" === n4) throw new Error("Generator is already running");
                if ("completed" === n4) {
                  if ("throw" === i3) throw a3;
                  return w();
                }
                for (r4.method = i3, r4.arg = a3; ; ) {
                  var o3 = r4.delegate;
                  if (o3) {
                    var s2 = S(o3, r4);
                    if (s2) {
                      if (s2 === d) continue;
                      return s2;
                    }
                  }
                  if ("next" === r4.method) r4.sent = r4._sent = r4.arg;
                  else if ("throw" === r4.method) {
                    if ("suspendedStart" === n4) throw n4 = "completed", r4.arg;
                    r4.dispatchException(r4.arg);
                  } else "return" === r4.method && r4.abrupt("return", r4.arg);
                  n4 = "executing";
                  var u2 = c(e4, t4, r4);
                  if ("normal" === u2.type) {
                    if (n4 = r4.done ? "completed" : "suspendedYield", u2.arg === d) continue;
                    return { value: u2.arg, done: r4.done };
                  }
                  "throw" === u2.type && (n4 = "completed", r4.method = "throw", r4.arg = u2.arg);
                }
              };
            }(e3, r3, o2), a2;
          }
          function c(e3, t3, r3) {
            try {
              return { type: "normal", arg: e3.call(t3, r3) };
            } catch (e4) {
              return { type: "throw", arg: e4 };
            }
          }
          e2.wrap = s;
          var d = {};
          function u() {
          }
          function l() {
          }
          function p() {
          }
          var f = {};
          f[i] = function() {
            return this;
          };
          var m = Object.getPrototypeOf, v = m && m(m(k([])));
          v && v !== t2 && r2.call(v, i) && (f = v);
          var h = p.prototype = u.prototype = Object.create(f);
          function g(e3) {
            ["next", "throw", "return"].forEach(function(t3) {
              e3[t3] = function(e4) {
                return this._invoke(t3, e4);
              };
            });
          }
          function y(e3, t3) {
            var n3;
            this._invoke = function(i2, a2) {
              function o2() {
                return new t3(function(n4, o3) {
                  !function n5(i3, a3, o4, s2) {
                    var d2 = c(e3[i3], e3, a3);
                    if ("throw" !== d2.type) {
                      var u2 = d2.arg, l2 = u2.value;
                      return l2 && "object" == typeof l2 && r2.call(l2, "__await") ? t3.resolve(l2.__await).then(function(e4) {
                        n5("next", e4, o4, s2);
                      }, function(e4) {
                        n5("throw", e4, o4, s2);
                      }) : t3.resolve(l2).then(function(e4) {
                        u2.value = e4, o4(u2);
                      }, function(e4) {
                        return n5("throw", e4, o4, s2);
                      });
                    }
                    s2(d2.arg);
                  }(i2, a2, n4, o3);
                });
              }
              return n3 = n3 ? n3.then(o2, o2) : o2();
            };
          }
          function S(e3, t3) {
            var r3 = e3.iterator[t3.method];
            if (void 0 === r3) {
              if (t3.delegate = null, "throw" === t3.method) {
                if (e3.iterator.return && (t3.method = "return", t3.arg = void 0, S(e3, t3), "throw" === t3.method)) return d;
                t3.method = "throw", t3.arg = new TypeError("The iterator does not provide a 'throw' method");
              }
              return d;
            }
            var n3 = c(r3, e3.iterator, t3.arg);
            if ("throw" === n3.type) return t3.method = "throw", t3.arg = n3.arg, t3.delegate = null, d;
            var i2 = n3.arg;
            return i2 ? i2.done ? (t3[e3.resultName] = i2.value, t3.next = e3.nextLoc, "return" !== t3.method && (t3.method = "next", t3.arg = void 0), t3.delegate = null, d) : i2 : (t3.method = "throw", t3.arg = new TypeError("iterator result is not an object"), t3.delegate = null, d);
          }
          function C(e3) {
            var t3 = { tryLoc: e3[0] };
            1 in e3 && (t3.catchLoc = e3[1]), 2 in e3 && (t3.finallyLoc = e3[2], t3.afterLoc = e3[3]), this.tryEntries.push(t3);
          }
          function T(e3) {
            var t3 = e3.completion || {};
            t3.type = "normal", delete t3.arg, e3.completion = t3;
          }
          function b(e3) {
            this.tryEntries = [{ tryLoc: "root" }], e3.forEach(C, this), this.reset(true);
          }
          function k(e3) {
            if (e3) {
              var t3 = e3[i];
              if (t3) return t3.call(e3);
              if ("function" == typeof e3.next) return e3;
              if (!isNaN(e3.length)) {
                var n3 = -1, a2 = function t4() {
                  for (; ++n3 < e3.length; ) if (r2.call(e3, n3)) return t4.value = e3[n3], t4.done = false, t4;
                  return t4.value = void 0, t4.done = true, t4;
                };
                return a2.next = a2;
              }
            }
            return { next: w };
          }
          function w() {
            return { value: void 0, done: true };
          }
          return l.prototype = h.constructor = p, p.constructor = l, p[o] = l.displayName = "GeneratorFunction", e2.isGeneratorFunction = function(e3) {
            var t3 = "function" == typeof e3 && e3.constructor;
            return !!t3 && (t3 === l || "GeneratorFunction" === (t3.displayName || t3.name));
          }, e2.mark = function(e3) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e3, p) : (e3.__proto__ = p, o in e3 || (e3[o] = "GeneratorFunction")), e3.prototype = Object.create(h), e3;
          }, e2.awrap = function(e3) {
            return { __await: e3 };
          }, g(y.prototype), y.prototype[a] = function() {
            return this;
          }, e2.AsyncIterator = y, e2.async = function(t3, r3, n3, i2, a2) {
            void 0 === a2 && (a2 = Promise);
            var o2 = new y(s(t3, r3, n3, i2), a2);
            return e2.isGeneratorFunction(r3) ? o2 : o2.next().then(function(e3) {
              return e3.done ? e3.value : o2.next();
            });
          }, g(h), h[o] = "Generator", h[i] = function() {
            return this;
          }, h.toString = function() {
            return "[object Generator]";
          }, e2.keys = function(e3) {
            var t3 = [];
            for (var r3 in e3) t3.push(r3);
            return t3.reverse(), function r4() {
              for (; t3.length; ) {
                var n3 = t3.pop();
                if (n3 in e3) return r4.value = n3, r4.done = false, r4;
              }
              return r4.done = true, r4;
            };
          }, e2.values = k, b.prototype = { constructor: b, reset: function(e3) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(T), !e3) for (var t3 in this) "t" === t3.charAt(0) && r2.call(this, t3) && !isNaN(+t3.slice(1)) && (this[t3] = void 0);
          }, stop: function() {
            this.done = true;
            var e3 = this.tryEntries[0].completion;
            if ("throw" === e3.type) throw e3.arg;
            return this.rval;
          }, dispatchException: function(e3) {
            if (this.done) throw e3;
            var t3 = this;
            function n3(r3, n4) {
              return o2.type = "throw", o2.arg = e3, t3.next = r3, n4 && (t3.method = "next", t3.arg = void 0), !!n4;
            }
            for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
              var a2 = this.tryEntries[i2], o2 = a2.completion;
              if ("root" === a2.tryLoc) return n3("end");
              if (a2.tryLoc <= this.prev) {
                var s2 = r2.call(a2, "catchLoc"), c2 = r2.call(a2, "finallyLoc");
                if (s2 && c2) {
                  if (this.prev < a2.catchLoc) return n3(a2.catchLoc, true);
                  if (this.prev < a2.finallyLoc) return n3(a2.finallyLoc);
                } else if (s2) {
                  if (this.prev < a2.catchLoc) return n3(a2.catchLoc, true);
                } else {
                  if (!c2) throw new Error("try statement without catch or finally");
                  if (this.prev < a2.finallyLoc) return n3(a2.finallyLoc);
                }
              }
            }
          }, abrupt: function(e3, t3) {
            for (var n3 = this.tryEntries.length - 1; n3 >= 0; --n3) {
              var i2 = this.tryEntries[n3];
              if (i2.tryLoc <= this.prev && r2.call(i2, "finallyLoc") && this.prev < i2.finallyLoc) {
                var a2 = i2;
                break;
              }
            }
            a2 && ("break" === e3 || "continue" === e3) && a2.tryLoc <= t3 && t3 <= a2.finallyLoc && (a2 = null);
            var o2 = a2 ? a2.completion : {};
            return o2.type = e3, o2.arg = t3, a2 ? (this.method = "next", this.next = a2.finallyLoc, d) : this.complete(o2);
          }, complete: function(e3, t3) {
            if ("throw" === e3.type) throw e3.arg;
            return "break" === e3.type || "continue" === e3.type ? this.next = e3.arg : "return" === e3.type ? (this.rval = this.arg = e3.arg, this.method = "return", this.next = "end") : "normal" === e3.type && t3 && (this.next = t3), d;
          }, finish: function(e3) {
            for (var t3 = this.tryEntries.length - 1; t3 >= 0; --t3) {
              var r3 = this.tryEntries[t3];
              if (r3.finallyLoc === e3) return this.complete(r3.completion, r3.afterLoc), T(r3), d;
            }
          }, catch: function(e3) {
            for (var t3 = this.tryEntries.length - 1; t3 >= 0; --t3) {
              var r3 = this.tryEntries[t3];
              if (r3.tryLoc === e3) {
                var n3 = r3.completion;
                if ("throw" === n3.type) {
                  var i2 = n3.arg;
                  T(r3);
                }
                return i2;
              }
            }
            throw new Error("illegal catch attempt");
          }, delegateYield: function(e3, t3, r3) {
            return this.delegate = { iterator: k(e3), resultName: t3, nextLoc: r3 }, "next" === this.method && (this.arg = void 0), d;
          } }, e2;
        }(e.exports);
        try {
          regeneratorRuntime = n;
        } catch (e2) {
          Function("r", "regeneratorRuntime = r")(n);
        }
      }, function(e, t) {
        var r;
        r = /* @__PURE__ */ function() {
          return this;
        }();
        try {
          r = r || new Function("return this")();
        } catch (e2) {
          "object" == typeof window && (r = window);
        }
        e.exports = r;
      }, function(e, t, r) {
        "use strict";
        var n = r(1);
        e.exports = function(e2, t2) {
          var i = e2 && e2.window, a = { shimChrome: true, shimFirefox: true, shimEdge: true, shimSafari: true };
          for (var o in t2) hasOwnProperty.call(t2, o) && (a[o] = t2[o]);
          var s = n.log, c = n.detectBrowser(i), d = r(7) || null, u = r(9) || null, l = r(13) || null, p = r(15) || null, f = r(16) || null, m = { browserDetails: c, commonShim: f, extractVersion: n.extractVersion, disableLog: n.disableLog, disableWarnings: n.disableWarnings };
          switch (c.browser) {
            case "chrome":
              if (!d || !d.shimPeerConnection || !a.shimChrome) return s("Chrome shim is not included in this adapter release."), m;
              s("adapter.js shimming chrome."), m.browserShim = d, f.shimCreateObjectURL(i), d.shimGetUserMedia(i), d.shimMediaStream(i), d.shimSourceObject(i), d.shimPeerConnection(i), d.shimOnTrack(i), d.shimAddTrackRemoveTrack(i), d.shimGetSendersWithDtmf(i), d.shimSenderReceiverGetStats(i), d.fixNegotiationNeeded(i), f.shimRTCIceCandidate(i), f.shimMaxMessageSize(i), f.shimSendThrowTypeError(i);
              break;
            case "firefox":
              if (!l || !l.shimPeerConnection || !a.shimFirefox) return s("Firefox shim is not included in this adapter release."), m;
              s("adapter.js shimming firefox."), m.browserShim = l, f.shimCreateObjectURL(i), l.shimGetUserMedia(i), l.shimSourceObject(i), l.shimPeerConnection(i), l.shimOnTrack(i), l.shimRemoveStream(i), l.shimSenderGetStats(i), l.shimReceiverGetStats(i), l.shimRTCDataChannel(i), f.shimRTCIceCandidate(i), f.shimMaxMessageSize(i), f.shimSendThrowTypeError(i);
              break;
            case "edge":
              if (!u || !u.shimPeerConnection || !a.shimEdge) return s("MS edge shim is not included in this adapter release."), m;
              s("adapter.js shimming edge."), m.browserShim = u, f.shimCreateObjectURL(i), u.shimGetUserMedia(i), u.shimPeerConnection(i), u.shimReplaceTrack(i), u.shimGetDisplayMedia(i), f.shimMaxMessageSize(i), f.shimSendThrowTypeError(i);
              break;
            case "safari":
              if (!p || !a.shimSafari) return s("Safari shim is not included in this adapter release."), m;
              s("adapter.js shimming safari."), m.browserShim = p, f.shimCreateObjectURL(i), p.shimRTCIceServerUrls(i), p.shimCreateOfferLegacy(i), p.shimCallbacksAPI(i), p.shimLocalStreamsAPI(i), p.shimRemoteStreamsAPI(i), p.shimTrackEventTransceiver(i), p.shimGetUserMedia(i), f.shimRTCIceCandidate(i), f.shimMaxMessageSize(i), f.shimSendThrowTypeError(i);
              break;
            default:
              s("Unsupported browser!");
          }
          return m;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(1), i = n.log;
        function a(e2, t2, r2) {
          var n2 = r2 ? "outbound-rtp" : "inbound-rtp", i2 = /* @__PURE__ */ new Map();
          if (null === t2) return i2;
          var a2 = [];
          return e2.forEach(function(e3) {
            "track" === e3.type && e3.trackIdentifier === t2.id && a2.push(e3);
          }), a2.forEach(function(t3) {
            e2.forEach(function(r3) {
              r3.type === n2 && r3.trackId === t3.id && function e3(t4, r4, n3) {
                r4 && !n3.has(r4.id) && (n3.set(r4.id, r4), Object.keys(r4).forEach(function(i3) {
                  i3.endsWith("Id") ? e3(t4, t4.get(r4[i3]), n3) : i3.endsWith("Ids") && r4[i3].forEach(function(r5) {
                    e3(t4, t4.get(r5), n3);
                  });
                }));
              }(e2, r3, i2);
            });
          }), i2;
        }
        e.exports = { shimGetUserMedia: r(8), shimMediaStream: function(e2) {
          e2.MediaStream = e2.MediaStream || e2.webkitMediaStream;
        }, shimOnTrack: function(e2) {
          if ("object" == typeof e2 && e2.RTCPeerConnection && !("ontrack" in e2.RTCPeerConnection.prototype)) {
            Object.defineProperty(e2.RTCPeerConnection.prototype, "ontrack", { get: function() {
              return this._ontrack;
            }, set: function(e3) {
              this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e3);
            }, enumerable: true, configurable: true });
            var t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
            e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
              var r2 = this;
              return r2._ontrackpoly || (r2._ontrackpoly = function(t3) {
                t3.stream.addEventListener("addtrack", function(n2) {
                  var i2;
                  i2 = e2.RTCPeerConnection.prototype.getReceivers ? r2.getReceivers().find(function(e3) {
                    return e3.track && e3.track.id === n2.track.id;
                  }) : { track: n2.track };
                  var a2 = new Event("track");
                  a2.track = n2.track, a2.receiver = i2, a2.transceiver = { receiver: i2 }, a2.streams = [t3.stream], r2.dispatchEvent(a2);
                }), t3.stream.getTracks().forEach(function(n2) {
                  var i2;
                  i2 = e2.RTCPeerConnection.prototype.getReceivers ? r2.getReceivers().find(function(e3) {
                    return e3.track && e3.track.id === n2.id;
                  }) : { track: n2 };
                  var a2 = new Event("track");
                  a2.track = n2, a2.receiver = i2, a2.transceiver = { receiver: i2 }, a2.streams = [t3.stream], r2.dispatchEvent(a2);
                });
              }, r2.addEventListener("addstream", r2._ontrackpoly)), t2.apply(r2, arguments);
            };
          } else n.wrapPeerConnectionEvent(e2, "track", function(e3) {
            return e3.transceiver || Object.defineProperty(e3, "transceiver", { value: { receiver: e3.receiver } }), e3;
          });
        }, shimGetSendersWithDtmf: function(e2) {
          if ("object" == typeof e2 && e2.RTCPeerConnection && !("getSenders" in e2.RTCPeerConnection.prototype) && "createDTMFSender" in e2.RTCPeerConnection.prototype) {
            var t2 = function(e3, t3) {
              return { track: t3, get dtmf() {
                return void 0 === this._dtmf && ("audio" === t3.kind ? this._dtmf = e3.createDTMFSender(t3) : this._dtmf = null), this._dtmf;
              }, _pc: e3 };
            };
            if (!e2.RTCPeerConnection.prototype.getSenders) {
              e2.RTCPeerConnection.prototype.getSenders = function() {
                return this._senders = this._senders || [], this._senders.slice();
              };
              var r2 = e2.RTCPeerConnection.prototype.addTrack;
              e2.RTCPeerConnection.prototype.addTrack = function(e3, n3) {
                var i3 = this, a3 = r2.apply(i3, arguments);
                return a3 || (a3 = t2(i3, e3), i3._senders.push(a3)), a3;
              };
              var n2 = e2.RTCPeerConnection.prototype.removeTrack;
              e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
                var t3 = this;
                n2.apply(t3, arguments);
                var r3 = t3._senders.indexOf(e3);
                -1 !== r3 && t3._senders.splice(r3, 1);
              };
            }
            var i2 = e2.RTCPeerConnection.prototype.addStream;
            e2.RTCPeerConnection.prototype.addStream = function(e3) {
              var r3 = this;
              r3._senders = r3._senders || [], i2.apply(r3, [e3]), e3.getTracks().forEach(function(e4) {
                r3._senders.push(t2(r3, e4));
              });
            };
            var a2 = e2.RTCPeerConnection.prototype.removeStream;
            e2.RTCPeerConnection.prototype.removeStream = function(e3) {
              var t3 = this;
              t3._senders = t3._senders || [], a2.apply(t3, [e3]), e3.getTracks().forEach(function(e4) {
                var r3 = t3._senders.find(function(t4) {
                  return t4.track === e4;
                });
                r3 && t3._senders.splice(t3._senders.indexOf(r3), 1);
              });
            };
          } else if ("object" == typeof e2 && e2.RTCPeerConnection && "getSenders" in e2.RTCPeerConnection.prototype && "createDTMFSender" in e2.RTCPeerConnection.prototype && e2.RTCRtpSender && !("dtmf" in e2.RTCRtpSender.prototype)) {
            var o = e2.RTCPeerConnection.prototype.getSenders;
            e2.RTCPeerConnection.prototype.getSenders = function() {
              var e3 = this, t3 = o.apply(e3, []);
              return t3.forEach(function(t4) {
                t4._pc = e3;
              }), t3;
            }, Object.defineProperty(e2.RTCRtpSender.prototype, "dtmf", { get: function() {
              return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
            } });
          }
        }, shimSenderReceiverGetStats: function(e2) {
          if ("object" == typeof e2 && e2.RTCPeerConnection && e2.RTCRtpSender && e2.RTCRtpReceiver) {
            if (!("getStats" in e2.RTCRtpSender.prototype)) {
              var t2 = e2.RTCPeerConnection.prototype.getSenders;
              t2 && (e2.RTCPeerConnection.prototype.getSenders = function() {
                var e3 = this, r3 = t2.apply(e3, []);
                return r3.forEach(function(t3) {
                  t3._pc = e3;
                }), r3;
              });
              var r2 = e2.RTCPeerConnection.prototype.addTrack;
              r2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
                var e3 = r2.apply(this, arguments);
                return e3._pc = this, e3;
              }), e2.RTCRtpSender.prototype.getStats = function() {
                var e3 = this;
                return this._pc.getStats().then(function(t3) {
                  return a(t3, e3.track, true);
                });
              };
            }
            if (!("getStats" in e2.RTCRtpReceiver.prototype)) {
              var i2 = e2.RTCPeerConnection.prototype.getReceivers;
              i2 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
                var e3 = this, t3 = i2.apply(e3, []);
                return t3.forEach(function(t4) {
                  t4._pc = e3;
                }), t3;
              }), n.wrapPeerConnectionEvent(e2, "track", function(e3) {
                return e3.receiver._pc = e3.srcElement, e3;
              }), e2.RTCRtpReceiver.prototype.getStats = function() {
                var e3 = this;
                return this._pc.getStats().then(function(t3) {
                  return a(t3, e3.track, false);
                });
              };
            }
            if ("getStats" in e2.RTCRtpSender.prototype && "getStats" in e2.RTCRtpReceiver.prototype) {
              var o = e2.RTCPeerConnection.prototype.getStats;
              e2.RTCPeerConnection.prototype.getStats = function() {
                var t3 = this;
                if (arguments.length > 0 && arguments[0] instanceof e2.MediaStreamTrack) {
                  var r3, n2, i3, a2 = arguments[0];
                  return t3.getSenders().forEach(function(e3) {
                    e3.track === a2 && (r3 ? i3 = true : r3 = e3);
                  }), t3.getReceivers().forEach(function(e3) {
                    return e3.track === a2 && (n2 ? i3 = true : n2 = e3), e3.track === a2;
                  }), i3 || r3 && n2 ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : r3 ? r3.getStats() : n2 ? n2.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
                }
                return o.apply(t3, arguments);
              };
            }
          }
        }, shimSourceObject: function(e2) {
          var t2 = e2 && e2.URL;
          "object" == typeof e2 && e2.HTMLMediaElement && !("srcObject" in e2.HTMLMediaElement.prototype) && Object.defineProperty(e2.HTMLMediaElement.prototype, "srcObject", { get: function() {
            return this._srcObject;
          }, set: function(e3) {
            var r2 = this;
            this._srcObject = e3, this.src && t2.revokeObjectURL(this.src), e3 ? (this.src = t2.createObjectURL(e3), e3.addEventListener("addtrack", function() {
              r2.src && t2.revokeObjectURL(r2.src), r2.src = t2.createObjectURL(e3);
            }), e3.addEventListener("removetrack", function() {
              r2.src && t2.revokeObjectURL(r2.src), r2.src = t2.createObjectURL(e3);
            })) : this.src = "";
          } });
        }, shimAddTrackRemoveTrackWithNative: function(e2) {
          e2.RTCPeerConnection.prototype.getLocalStreams = function() {
            var e3 = this;
            return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(function(t3) {
              return e3._shimmedLocalStreams[t3][0];
            });
          };
          var t2 = e2.RTCPeerConnection.prototype.addTrack;
          e2.RTCPeerConnection.prototype.addTrack = function(e3, r3) {
            if (!r3) return t2.apply(this, arguments);
            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            var n3 = t2.apply(this, arguments);
            return this._shimmedLocalStreams[r3.id] ? -1 === this._shimmedLocalStreams[r3.id].indexOf(n3) && this._shimmedLocalStreams[r3.id].push(n3) : this._shimmedLocalStreams[r3.id] = [r3, n3], n3;
          };
          var r2 = e2.RTCPeerConnection.prototype.addStream;
          e2.RTCPeerConnection.prototype.addStream = function(e3) {
            var t3 = this;
            this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3.getTracks().forEach(function(e4) {
              if (t3.getSenders().find(function(t4) {
                return t4.track === e4;
              })) throw new DOMException("Track already exists.", "InvalidAccessError");
            });
            var n3 = t3.getSenders();
            r2.apply(this, arguments);
            var i3 = t3.getSenders().filter(function(e4) {
              return -1 === n3.indexOf(e4);
            });
            this._shimmedLocalStreams[e3.id] = [e3].concat(i3);
          };
          var n2 = e2.RTCPeerConnection.prototype.removeStream;
          e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e3.id], n2.apply(this, arguments);
          };
          var i2 = e2.RTCPeerConnection.prototype.removeTrack;
          e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
            var t3 = this;
            return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3 && Object.keys(this._shimmedLocalStreams).forEach(function(r3) {
              var n3 = t3._shimmedLocalStreams[r3].indexOf(e3);
              -1 !== n3 && t3._shimmedLocalStreams[r3].splice(n3, 1), 1 === t3._shimmedLocalStreams[r3].length && delete t3._shimmedLocalStreams[r3];
            }), i2.apply(this, arguments);
          };
        }, shimAddTrackRemoveTrack: function(e2) {
          if (e2.RTCPeerConnection) {
            var t2 = n.detectBrowser(e2);
            if (e2.RTCPeerConnection.prototype.addTrack && t2.version >= 65) return this.shimAddTrackRemoveTrackWithNative(e2);
            var r2 = e2.RTCPeerConnection.prototype.getLocalStreams;
            e2.RTCPeerConnection.prototype.getLocalStreams = function() {
              var e3 = this, t3 = r2.apply(this);
              return e3._reverseStreams = e3._reverseStreams || {}, t3.map(function(t4) {
                return e3._reverseStreams[t4.id];
              });
            };
            var i2 = e2.RTCPeerConnection.prototype.addStream;
            e2.RTCPeerConnection.prototype.addStream = function(t3) {
              var r3 = this;
              if (r3._streams = r3._streams || {}, r3._reverseStreams = r3._reverseStreams || {}, t3.getTracks().forEach(function(e3) {
                if (r3.getSenders().find(function(t4) {
                  return t4.track === e3;
                })) throw new DOMException("Track already exists.", "InvalidAccessError");
              }), !r3._reverseStreams[t3.id]) {
                var n2 = new e2.MediaStream(t3.getTracks());
                r3._streams[t3.id] = n2, r3._reverseStreams[n2.id] = t3, t3 = n2;
              }
              i2.apply(r3, [t3]);
            };
            var a2 = e2.RTCPeerConnection.prototype.removeStream;
            e2.RTCPeerConnection.prototype.removeStream = function(e3) {
              var t3 = this;
              t3._streams = t3._streams || {}, t3._reverseStreams = t3._reverseStreams || {}, a2.apply(t3, [t3._streams[e3.id] || e3]), delete t3._reverseStreams[t3._streams[e3.id] ? t3._streams[e3.id].id : e3.id], delete t3._streams[e3.id];
            }, e2.RTCPeerConnection.prototype.addTrack = function(t3, r3) {
              var n2 = this;
              if ("closed" === n2.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
              var i3 = [].slice.call(arguments, 1);
              if (1 !== i3.length || !i3[0].getTracks().find(function(e3) {
                return e3 === t3;
              })) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
              var a3 = n2.getSenders().find(function(e3) {
                return e3.track === t3;
              });
              if (a3) throw new DOMException("Track already exists.", "InvalidAccessError");
              n2._streams = n2._streams || {}, n2._reverseStreams = n2._reverseStreams || {};
              var o2 = n2._streams[r3.id];
              if (o2) o2.addTrack(t3), Promise.resolve().then(function() {
                n2.dispatchEvent(new Event("negotiationneeded"));
              });
              else {
                var s2 = new e2.MediaStream([t3]);
                n2._streams[r3.id] = s2, n2._reverseStreams[s2.id] = r3, n2.addStream(s2);
              }
              return n2.getSenders().find(function(e3) {
                return e3.track === t3;
              });
            }, ["createOffer", "createAnswer"].forEach(function(t3) {
              var r3 = e2.RTCPeerConnection.prototype[t3];
              e2.RTCPeerConnection.prototype[t3] = function() {
                var e3 = this, t4 = arguments, n2 = arguments.length && "function" == typeof arguments[0];
                return n2 ? r3.apply(e3, [function(r4) {
                  var n3 = c(e3, r4);
                  t4[0].apply(null, [n3]);
                }, function(e4) {
                  t4[1] && t4[1].apply(null, e4);
                }, arguments[2]]) : r3.apply(e3, arguments).then(function(t5) {
                  return c(e3, t5);
                });
              };
            });
            var o = e2.RTCPeerConnection.prototype.setLocalDescription;
            e2.RTCPeerConnection.prototype.setLocalDescription = function() {
              var e3 = this;
              return arguments.length && arguments[0].type ? (arguments[0] = d(e3, arguments[0]), o.apply(e3, arguments)) : o.apply(e3, arguments);
            };
            var s = Object.getOwnPropertyDescriptor(e2.RTCPeerConnection.prototype, "localDescription");
            Object.defineProperty(e2.RTCPeerConnection.prototype, "localDescription", { get: function() {
              var e3 = s.get.apply(this);
              return "" === e3.type ? e3 : c(this, e3);
            } }), e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
              var t3, r3 = this;
              if ("closed" === r3.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
              if (!e3._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
              if (!(e3._pc === r3)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
              r3._streams = r3._streams || {}, Object.keys(r3._streams).forEach(function(n2) {
                r3._streams[n2].getTracks().find(function(t4) {
                  return e3.track === t4;
                }) && (t3 = r3._streams[n2]);
              }), t3 && (1 === t3.getTracks().length ? r3.removeStream(r3._reverseStreams[t3.id]) : t3.removeTrack(e3.track), r3.dispatchEvent(new Event("negotiationneeded")));
            };
          }
          function c(e3, t3) {
            var r3 = t3.sdp;
            return Object.keys(e3._reverseStreams || []).forEach(function(t4) {
              var n2 = e3._reverseStreams[t4], i3 = e3._streams[n2.id];
              r3 = r3.replace(new RegExp(i3.id, "g"), n2.id);
            }), new RTCSessionDescription({ type: t3.type, sdp: r3 });
          }
          function d(e3, t3) {
            var r3 = t3.sdp;
            return Object.keys(e3._reverseStreams || []).forEach(function(t4) {
              var n2 = e3._reverseStreams[t4], i3 = e3._streams[n2.id];
              r3 = r3.replace(new RegExp(n2.id, "g"), i3.id);
            }), new RTCSessionDescription({ type: t3.type, sdp: r3 });
          }
        }, shimPeerConnection: function(e2) {
          var t2 = n.detectBrowser(e2);
          if (!e2.RTCPeerConnection && e2.webkitRTCPeerConnection && (e2.RTCPeerConnection = function(t3, r3) {
            return i("PeerConnection"), t3 && t3.iceTransportPolicy && (t3.iceTransports = t3.iceTransportPolicy), new e2.webkitRTCPeerConnection(t3, r3);
          }, e2.RTCPeerConnection.prototype = e2.webkitRTCPeerConnection.prototype, e2.webkitRTCPeerConnection.generateCertificate && Object.defineProperty(e2.RTCPeerConnection, "generateCertificate", { get: function() {
            return e2.webkitRTCPeerConnection.generateCertificate;
          } })), e2.RTCPeerConnection) {
            var r2 = e2.RTCPeerConnection.prototype.getStats;
            e2.RTCPeerConnection.prototype.getStats = function(e3, t3, n2) {
              var i2 = this, a3 = arguments;
              if (arguments.length > 0 && "function" == typeof e3) return r2.apply(this, arguments);
              if (0 === r2.length && (0 === arguments.length || "function" != typeof arguments[0])) return r2.apply(this, []);
              var o = function(e4) {
                var t4 = {};
                return e4.result().forEach(function(e5) {
                  var r3 = { id: e5.id, timestamp: e5.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e5.type] || e5.type };
                  e5.names().forEach(function(t5) {
                    r3[t5] = e5.stat(t5);
                  }), t4[r3.id] = r3;
                }), t4;
              }, s = function(e4) {
                return new Map(Object.keys(e4).map(function(t4) {
                  return [t4, e4[t4]];
                }));
              };
              if (arguments.length >= 2) {
                var c = function(e4) {
                  a3[1](s(o(e4)));
                };
                return r2.apply(this, [c, arguments[0]]);
              }
              return new Promise(function(e4, t4) {
                r2.apply(i2, [function(t5) {
                  e4(s(o(t5)));
                }, t4]);
              }).then(t3, n2);
            }, t2.version < 51 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
              var r3 = e2.RTCPeerConnection.prototype[t3];
              e2.RTCPeerConnection.prototype[t3] = function() {
                var e3 = arguments, t4 = this, n2 = new Promise(function(n3, i2) {
                  r3.apply(t4, [e3[0], n3, i2]);
                });
                return e3.length < 2 ? n2 : n2.then(function() {
                  e3[1].apply(null, []);
                }, function(t5) {
                  e3.length >= 3 && e3[2].apply(null, [t5]);
                });
              };
            }), t2.version < 52 && ["createOffer", "createAnswer"].forEach(function(t3) {
              var r3 = e2.RTCPeerConnection.prototype[t3];
              e2.RTCPeerConnection.prototype[t3] = function() {
                var e3 = this;
                if (arguments.length < 1 || 1 === arguments.length && "object" == typeof arguments[0]) {
                  var t4 = 1 === arguments.length ? arguments[0] : void 0;
                  return new Promise(function(n2, i2) {
                    r3.apply(e3, [n2, i2, t4]);
                  });
                }
                return r3.apply(this, arguments);
              };
            }), ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
              var r3 = e2.RTCPeerConnection.prototype[t3];
              e2.RTCPeerConnection.prototype[t3] = function() {
                return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), r3.apply(this, arguments);
              };
            });
            var a2 = e2.RTCPeerConnection.prototype.addIceCandidate;
            e2.RTCPeerConnection.prototype.addIceCandidate = function() {
              return arguments[0] ? a2.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
            };
          }
        }, fixNegotiationNeeded: function(e2) {
          n.wrapPeerConnectionEvent(e2, "negotiationneeded", function(e3) {
            if ("stable" === e3.target.signalingState) return e3;
          });
        }, shimGetDisplayMedia: function(e2, t2) {
          e2.navigator && e2.navigator.mediaDevices && !("getDisplayMedia" in e2.navigator.mediaDevices) && ("function" == typeof t2 ? (e2.navigator.mediaDevices.getDisplayMedia = function(r2) {
            return t2(r2).then(function(t3) {
              var n2 = r2.video && r2.video.width, i2 = r2.video && r2.video.height, a2 = r2.video && r2.video.frameRate;
              return r2.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t3, maxFrameRate: a2 || 3 } }, n2 && (r2.video.mandatory.maxWidth = n2), i2 && (r2.video.mandatory.maxHeight = i2), e2.navigator.mediaDevices.getUserMedia(r2);
            });
          }, e2.navigator.getDisplayMedia = function(t3) {
            return n.deprecated("navigator.getDisplayMedia", "navigator.mediaDevices.getDisplayMedia"), e2.navigator.mediaDevices.getDisplayMedia(t3);
          }) : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
        } };
      }, function(e, t, r) {
        "use strict";
        var n = r(1), i = n.log;
        e.exports = function(e2) {
          var t2 = n.detectBrowser(e2), r2 = e2 && e2.navigator, a = function(e3) {
            if ("object" != typeof e3 || e3.mandatory || e3.optional) return e3;
            var t3 = {};
            return Object.keys(e3).forEach(function(r3) {
              if ("require" !== r3 && "advanced" !== r3 && "mediaSource" !== r3) {
                var n2 = "object" == typeof e3[r3] ? e3[r3] : { ideal: e3[r3] };
                void 0 !== n2.exact && "number" == typeof n2.exact && (n2.min = n2.max = n2.exact);
                var i2 = function(e4, t4) {
                  return e4 ? e4 + t4.charAt(0).toUpperCase() + t4.slice(1) : "deviceId" === t4 ? "sourceId" : t4;
                };
                if (void 0 !== n2.ideal) {
                  t3.optional = t3.optional || [];
                  var a2 = {};
                  "number" == typeof n2.ideal ? (a2[i2("min", r3)] = n2.ideal, t3.optional.push(a2), (a2 = {})[i2("max", r3)] = n2.ideal, t3.optional.push(a2)) : (a2[i2("", r3)] = n2.ideal, t3.optional.push(a2));
                }
                void 0 !== n2.exact && "number" != typeof n2.exact ? (t3.mandatory = t3.mandatory || {}, t3.mandatory[i2("", r3)] = n2.exact) : ["min", "max"].forEach(function(e4) {
                  void 0 !== n2[e4] && (t3.mandatory = t3.mandatory || {}, t3.mandatory[i2(e4, r3)] = n2[e4]);
                });
              }
            }), e3.advanced && (t3.optional = (t3.optional || []).concat(e3.advanced)), t3;
          }, o = function(e3, n2) {
            if (t2.version >= 61) return n2(e3);
            if ((e3 = JSON.parse(JSON.stringify(e3))) && "object" == typeof e3.audio) {
              var o2 = function(e4, t3, r3) {
                t3 in e4 && !(r3 in e4) && (e4[r3] = e4[t3], delete e4[t3]);
              };
              o2((e3 = JSON.parse(JSON.stringify(e3))).audio, "autoGainControl", "googAutoGainControl"), o2(e3.audio, "noiseSuppression", "googNoiseSuppression"), e3.audio = a(e3.audio);
            }
            if (e3 && "object" == typeof e3.video) {
              var s2 = e3.video.facingMode;
              s2 = s2 && ("object" == typeof s2 ? s2 : { ideal: s2 });
              var c2, d2 = t2.version < 66;
              if (s2 && ("user" === s2.exact || "environment" === s2.exact || "user" === s2.ideal || "environment" === s2.ideal) && (!r2.mediaDevices.getSupportedConstraints || !r2.mediaDevices.getSupportedConstraints().facingMode || d2)) {
                if (delete e3.video.facingMode, "environment" === s2.exact || "environment" === s2.ideal ? c2 = ["back", "rear"] : "user" !== s2.exact && "user" !== s2.ideal || (c2 = ["front"]), c2) return r2.mediaDevices.enumerateDevices().then(function(t3) {
                  var r3 = (t3 = t3.filter(function(e4) {
                    return "videoinput" === e4.kind;
                  })).find(function(e4) {
                    return c2.some(function(t4) {
                      return -1 !== e4.label.toLowerCase().indexOf(t4);
                    });
                  });
                  return !r3 && t3.length && -1 !== c2.indexOf("back") && (r3 = t3[t3.length - 1]), r3 && (e3.video.deviceId = s2.exact ? { exact: r3.deviceId } : { ideal: r3.deviceId }), e3.video = a(e3.video), i("chrome: " + JSON.stringify(e3)), n2(e3);
                });
              }
              e3.video = a(e3.video);
            }
            return i("chrome: " + JSON.stringify(e3)), n2(e3);
          }, s = function(e3) {
            return t2.version >= 64 ? e3 : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e3.name] || e3.name, message: e3.message, constraint: e3.constraint || e3.constraintName, toString: function() {
              return this.name + (this.message && ": ") + this.message;
            } };
          };
          r2.getUserMedia = function(e3, t3, n2) {
            o(e3, function(e4) {
              r2.webkitGetUserMedia(e4, t3, function(e5) {
                n2 && n2(s(e5));
              });
            });
          };
          var c = function(e3) {
            return new Promise(function(t3, n2) {
              r2.getUserMedia(e3, t3, n2);
            });
          };
          if (r2.mediaDevices || (r2.mediaDevices = { getUserMedia: c, enumerateDevices: function() {
            return new Promise(function(t3) {
              var r3 = { audio: "audioinput", video: "videoinput" };
              return e2.MediaStreamTrack.getSources(function(e3) {
                t3(e3.map(function(e4) {
                  return { label: e4.label, kind: r3[e4.kind], deviceId: e4.id, groupId: "" };
                }));
              });
            });
          }, getSupportedConstraints: function() {
            return { deviceId: true, echoCancellation: true, facingMode: true, frameRate: true, height: true, width: true };
          } }), r2.mediaDevices.getUserMedia) {
            var d = r2.mediaDevices.getUserMedia.bind(r2.mediaDevices);
            r2.mediaDevices.getUserMedia = function(e3) {
              return o(e3, function(e4) {
                return d(e4).then(function(t3) {
                  if (e4.audio && !t3.getAudioTracks().length || e4.video && !t3.getVideoTracks().length) throw t3.getTracks().forEach(function(e5) {
                    e5.stop();
                  }), new DOMException("", "NotFoundError");
                  return t3;
                }, function(e5) {
                  return Promise.reject(s(e5));
                });
              });
            };
          } else r2.mediaDevices.getUserMedia = function(e3) {
            return c(e3);
          };
          void 0 === r2.mediaDevices.addEventListener && (r2.mediaDevices.addEventListener = function() {
            i("Dummy mediaDevices.addEventListener called.");
          }), void 0 === r2.mediaDevices.removeEventListener && (r2.mediaDevices.removeEventListener = function() {
            i("Dummy mediaDevices.removeEventListener called.");
          });
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(1), i = r(10), a = r(11);
        e.exports = { shimGetUserMedia: r(12), shimPeerConnection: function(e2) {
          var t2 = n.detectBrowser(e2);
          if (e2.RTCIceGatherer && (e2.RTCIceCandidate || (e2.RTCIceCandidate = function(e3) {
            return e3;
          }), e2.RTCSessionDescription || (e2.RTCSessionDescription = function(e3) {
            return e3;
          }), t2.version < 15025)) {
            var r2 = Object.getOwnPropertyDescriptor(e2.MediaStreamTrack.prototype, "enabled");
            Object.defineProperty(e2.MediaStreamTrack.prototype, "enabled", { set: function(e3) {
              r2.set.call(this, e3);
              var t3 = new Event("enabled");
              t3.enabled = e3, this.dispatchEvent(t3);
            } });
          }
          e2.RTCRtpSender && !("dtmf" in e2.RTCRtpSender.prototype) && Object.defineProperty(e2.RTCRtpSender.prototype, "dtmf", { get: function() {
            return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = new e2.RTCDtmfSender(this) : "video" === this.track.kind && (this._dtmf = null)), this._dtmf;
          } }), e2.RTCDtmfSender && !e2.RTCDTMFSender && (e2.RTCDTMFSender = e2.RTCDtmfSender);
          var o = a(e2, t2.version);
          e2.RTCPeerConnection = function(e3) {
            return e3 && e3.iceServers && (e3.iceServers = i(e3.iceServers)), new o(e3);
          }, e2.RTCPeerConnection.prototype = o.prototype;
        }, shimReplaceTrack: function(e2) {
          e2.RTCRtpSender && !("replaceTrack" in e2.RTCRtpSender.prototype) && (e2.RTCRtpSender.prototype.replaceTrack = e2.RTCRtpSender.prototype.setTrack);
        }, shimGetDisplayMedia: function(e2, t2) {
          if ("getDisplayMedia" in e2.navigator && e2.navigator.mediaDevices && !("getDisplayMedia" in e2.navigator.mediaDevices)) {
            var r2 = e2.navigator.getDisplayMedia;
            e2.navigator.mediaDevices.getDisplayMedia = function(t3) {
              return r2.call(e2.navigator, t3);
            }, e2.navigator.getDisplayMedia = function(t3) {
              return n.deprecated("navigator.getDisplayMedia", "navigator.mediaDevices.getDisplayMedia"), r2.call(e2.navigator, t3);
            };
          }
        } };
      }, function(e, t, r) {
        "use strict";
        var n = r(1);
        e.exports = function(e2, t2) {
          var r2 = false;
          return (e2 = JSON.parse(JSON.stringify(e2))).filter(function(e3) {
            if (e3 && (e3.urls || e3.url)) {
              var i = e3.urls || e3.url;
              e3.url && !e3.urls && n.deprecated("RTCIceServer.url", "RTCIceServer.urls");
              var a = "string" == typeof i;
              return a && (i = [i]), i = i.filter(function(e4) {
                return 0 === e4.indexOf("turn:") && -1 !== e4.indexOf("transport=udp") && -1 === e4.indexOf("turn:[") && !r2 ? (r2 = true, true) : 0 === e4.indexOf("stun:") && t2 >= 14393 && -1 === e4.indexOf("?transport=udp");
              }), delete e3.url, e3.urls = a ? i[0] : i, !!i.length;
            }
          });
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(2);
        function i(e2, t2, r2, i2, a2) {
          var o2 = n.writeRtpDescription(e2.kind, t2);
          if (o2 += n.writeIceParameters(e2.iceGatherer.getLocalParameters()), o2 += n.writeDtlsParameters(e2.dtlsTransport.getLocalParameters(), "offer" === r2 ? "actpass" : a2 || "active"), o2 += "a=mid:" + e2.mid + "\r\n", e2.rtpSender && e2.rtpReceiver ? o2 += "a=sendrecv\r\n" : e2.rtpSender ? o2 += "a=sendonly\r\n" : e2.rtpReceiver ? o2 += "a=recvonly\r\n" : o2 += "a=inactive\r\n", e2.rtpSender) {
            var s2 = e2.rtpSender._initialTrackId || e2.rtpSender.track.id;
            e2.rtpSender._initialTrackId = s2;
            var c2 = "msid:" + (i2 ? i2.id : "-") + " " + s2 + "\r\n";
            o2 += "a=" + c2, o2 += "a=ssrc:" + e2.sendEncodingParameters[0].ssrc + " " + c2, e2.sendEncodingParameters[0].rtx && (o2 += "a=ssrc:" + e2.sendEncodingParameters[0].rtx.ssrc + " " + c2, o2 += "a=ssrc-group:FID " + e2.sendEncodingParameters[0].ssrc + " " + e2.sendEncodingParameters[0].rtx.ssrc + "\r\n");
          }
          return o2 += "a=ssrc:" + e2.sendEncodingParameters[0].ssrc + " cname:" + n.localCName + "\r\n", e2.rtpSender && e2.sendEncodingParameters[0].rtx && (o2 += "a=ssrc:" + e2.sendEncodingParameters[0].rtx.ssrc + " cname:" + n.localCName + "\r\n"), o2;
        }
        function a(e2, t2) {
          var r2 = { codecs: [], headerExtensions: [], fecMechanisms: [] }, n2 = function(e3, t3) {
            e3 = parseInt(e3, 10);
            for (var r3 = 0; r3 < t3.length; r3++) if (t3[r3].payloadType === e3 || t3[r3].preferredPayloadType === e3) return t3[r3];
          }, i2 = function(e3, t3, r3, i3) {
            var a2 = n2(e3.parameters.apt, r3), o2 = n2(t3.parameters.apt, i3);
            return a2 && o2 && a2.name.toLowerCase() === o2.name.toLowerCase();
          };
          return e2.codecs.forEach(function(n3) {
            for (var a2 = 0; a2 < t2.codecs.length; a2++) {
              var o2 = t2.codecs[a2];
              if (n3.name.toLowerCase() === o2.name.toLowerCase() && n3.clockRate === o2.clockRate) {
                if ("rtx" === n3.name.toLowerCase() && n3.parameters && o2.parameters.apt && !i2(n3, o2, e2.codecs, t2.codecs)) continue;
                (o2 = JSON.parse(JSON.stringify(o2))).numChannels = Math.min(n3.numChannels, o2.numChannels), r2.codecs.push(o2), o2.rtcpFeedback = o2.rtcpFeedback.filter(function(e3) {
                  for (var t3 = 0; t3 < n3.rtcpFeedback.length; t3++) if (n3.rtcpFeedback[t3].type === e3.type && n3.rtcpFeedback[t3].parameter === e3.parameter) return true;
                  return false;
                });
                break;
              }
            }
          }), e2.headerExtensions.forEach(function(e3) {
            for (var n3 = 0; n3 < t2.headerExtensions.length; n3++) {
              var i3 = t2.headerExtensions[n3];
              if (e3.uri === i3.uri) {
                r2.headerExtensions.push(i3);
                break;
              }
            }
          }), r2;
        }
        function o(e2, t2, r2) {
          return -1 !== { offer: { setLocalDescription: ["stable", "have-local-offer"], setRemoteDescription: ["stable", "have-remote-offer"] }, answer: { setLocalDescription: ["have-remote-offer", "have-local-pranswer"], setRemoteDescription: ["have-local-offer", "have-remote-pranswer"] } }[t2][e2].indexOf(r2);
        }
        function s(e2, t2) {
          var r2 = e2.getRemoteCandidates().find(function(e3) {
            return t2.foundation === e3.foundation && t2.ip === e3.ip && t2.port === e3.port && t2.priority === e3.priority && t2.protocol === e3.protocol && t2.type === e3.type;
          });
          return r2 || e2.addRemoteCandidate(t2), !r2;
        }
        function c(e2, t2) {
          var r2 = new Error(t2);
          return r2.name = e2, r2.code = { NotSupportedError: 9, InvalidStateError: 11, InvalidAccessError: 15, TypeError: void 0, OperationError: void 0 }[e2], r2;
        }
        e.exports = function(e2, t2) {
          function r2(t3, r3) {
            r3.addTrack(t3), r3.dispatchEvent(new e2.MediaStreamTrackEvent("addtrack", { track: t3 }));
          }
          function d(t3, r3, n2, i2) {
            var a2 = new Event("track");
            a2.track = r3, a2.receiver = n2, a2.transceiver = { receiver: n2 }, a2.streams = i2, e2.setTimeout(function() {
              t3._dispatchEvent("track", a2);
            });
          }
          var u = function(r3) {
            var i2 = this, a2 = document.createDocumentFragment();
            if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function(e3) {
              i2[e3] = a2[e3].bind(a2);
            }), this.canTrickleIceCandidates = null, this.needNegotiation = false, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", r3 = JSON.parse(JSON.stringify(r3 || {})), this.usingBundle = "max-bundle" === r3.bundlePolicy, "negotiate" === r3.rtcpMuxPolicy) throw c("NotSupportedError", "rtcpMuxPolicy 'negotiate' is not supported");
            switch (r3.rtcpMuxPolicy || (r3.rtcpMuxPolicy = "require"), r3.iceTransportPolicy) {
              case "all":
              case "relay":
                break;
              default:
                r3.iceTransportPolicy = "all";
            }
            switch (r3.bundlePolicy) {
              case "balanced":
              case "max-compat":
              case "max-bundle":
                break;
              default:
                r3.bundlePolicy = "balanced";
            }
            if (r3.iceServers = function(e3, t3) {
              var r4 = false;
              return (e3 = JSON.parse(JSON.stringify(e3))).filter(function(e4) {
                if (e4 && (e4.urls || e4.url)) {
                  var n2 = e4.urls || e4.url;
                  e4.url && !e4.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead.");
                  var i3 = "string" == typeof n2;
                  return i3 && (n2 = [n2]), n2 = n2.filter(function(e5) {
                    return 0 === e5.indexOf("turn:") && -1 !== e5.indexOf("transport=udp") && -1 === e5.indexOf("turn:[") && !r4 ? (r4 = true, true) : 0 === e5.indexOf("stun:") && t3 >= 14393 && -1 === e5.indexOf("?transport=udp");
                  }), delete e4.url, e4.urls = i3 ? n2[0] : n2, !!n2.length;
                }
              });
            }(r3.iceServers || [], t2), this._iceGatherers = [], r3.iceCandidatePoolSize) for (var o2 = r3.iceCandidatePoolSize; o2 > 0; o2--) this._iceGatherers.push(new e2.RTCIceGatherer({ iceServers: r3.iceServers, gatherPolicy: r3.iceTransportPolicy }));
            else r3.iceCandidatePoolSize = 0;
            this._config = r3, this.transceivers = [], this._sdpSessionId = n.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = false;
          };
          Object.defineProperty(u.prototype, "localDescription", { configurable: true, get: function() {
            return this._localDescription;
          } }), Object.defineProperty(u.prototype, "remoteDescription", { configurable: true, get: function() {
            return this._remoteDescription;
          } }), u.prototype.onicecandidate = null, u.prototype.onaddstream = null, u.prototype.ontrack = null, u.prototype.onremovestream = null, u.prototype.onsignalingstatechange = null, u.prototype.oniceconnectionstatechange = null, u.prototype.onconnectionstatechange = null, u.prototype.onicegatheringstatechange = null, u.prototype.onnegotiationneeded = null, u.prototype.ondatachannel = null, u.prototype._dispatchEvent = function(e3, t3) {
            this._isClosed || (this.dispatchEvent(t3), "function" == typeof this["on" + e3] && this["on" + e3](t3));
          }, u.prototype._emitGatheringStateChange = function() {
            var e3 = new Event("icegatheringstatechange");
            this._dispatchEvent("icegatheringstatechange", e3);
          }, u.prototype.getConfiguration = function() {
            return this._config;
          }, u.prototype.getLocalStreams = function() {
            return this.localStreams;
          }, u.prototype.getRemoteStreams = function() {
            return this.remoteStreams;
          }, u.prototype._createTransceiver = function(e3, t3) {
            var r3 = this.transceivers.length > 0, n2 = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: e3, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, associatedRemoteMediaStreams: [], wantReceive: true };
            if (this.usingBundle && r3) n2.iceTransport = this.transceivers[0].iceTransport, n2.dtlsTransport = this.transceivers[0].dtlsTransport;
            else {
              var i2 = this._createIceAndDtlsTransports();
              n2.iceTransport = i2.iceTransport, n2.dtlsTransport = i2.dtlsTransport;
            }
            return t3 || this.transceivers.push(n2), n2;
          }, u.prototype.addTrack = function(t3, r3) {
            if (this._isClosed) throw c("InvalidStateError", "Attempted to call addTrack on a closed peerconnection.");
            var n2;
            if (this.transceivers.find(function(e3) {
              return e3.track === t3;
            })) throw c("InvalidAccessError", "Track already exists.");
            for (var i2 = 0; i2 < this.transceivers.length; i2++) this.transceivers[i2].track || this.transceivers[i2].kind !== t3.kind || (n2 = this.transceivers[i2]);
            return n2 || (n2 = this._createTransceiver(t3.kind)), this._maybeFireNegotiationNeeded(), -1 === this.localStreams.indexOf(r3) && this.localStreams.push(r3), n2.track = t3, n2.stream = r3, n2.rtpSender = new e2.RTCRtpSender(t3, n2.dtlsTransport), n2.rtpSender;
          }, u.prototype.addStream = function(e3) {
            var r3 = this;
            if (t2 >= 15025) e3.getTracks().forEach(function(t3) {
              r3.addTrack(t3, e3);
            });
            else {
              var n2 = e3.clone();
              e3.getTracks().forEach(function(e4, t3) {
                var r4 = n2.getTracks()[t3];
                e4.addEventListener("enabled", function(e5) {
                  r4.enabled = e5.enabled;
                });
              }), n2.getTracks().forEach(function(e4) {
                r3.addTrack(e4, n2);
              });
            }
          }, u.prototype.removeTrack = function(t3) {
            if (this._isClosed) throw c("InvalidStateError", "Attempted to call removeTrack on a closed peerconnection.");
            if (!(t3 instanceof e2.RTCRtpSender)) throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.");
            var r3 = this.transceivers.find(function(e3) {
              return e3.rtpSender === t3;
            });
            if (!r3) throw c("InvalidAccessError", "Sender was not created by this connection.");
            var n2 = r3.stream;
            r3.rtpSender.stop(), r3.rtpSender = null, r3.track = null, r3.stream = null, -1 === this.transceivers.map(function(e3) {
              return e3.stream;
            }).indexOf(n2) && this.localStreams.indexOf(n2) > -1 && this.localStreams.splice(this.localStreams.indexOf(n2), 1), this._maybeFireNegotiationNeeded();
          }, u.prototype.removeStream = function(e3) {
            var t3 = this;
            e3.getTracks().forEach(function(e4) {
              var r3 = t3.getSenders().find(function(t4) {
                return t4.track === e4;
              });
              r3 && t3.removeTrack(r3);
            });
          }, u.prototype.getSenders = function() {
            return this.transceivers.filter(function(e3) {
              return !!e3.rtpSender;
            }).map(function(e3) {
              return e3.rtpSender;
            });
          }, u.prototype.getReceivers = function() {
            return this.transceivers.filter(function(e3) {
              return !!e3.rtpReceiver;
            }).map(function(e3) {
              return e3.rtpReceiver;
            });
          }, u.prototype._createIceGatherer = function(t3, r3) {
            var n2 = this;
            if (r3 && t3 > 0) return this.transceivers[0].iceGatherer;
            if (this._iceGatherers.length) return this._iceGatherers.shift();
            var i2 = new e2.RTCIceGatherer({ iceServers: this._config.iceServers, gatherPolicy: this._config.iceTransportPolicy });
            return Object.defineProperty(i2, "state", { value: "new", writable: true }), this.transceivers[t3].bufferedCandidateEvents = [], this.transceivers[t3].bufferCandidates = function(e3) {
              var r4 = !e3.candidate || 0 === Object.keys(e3.candidate).length;
              i2.state = r4 ? "completed" : "gathering", null !== n2.transceivers[t3].bufferedCandidateEvents && n2.transceivers[t3].bufferedCandidateEvents.push(e3);
            }, i2.addEventListener("localcandidate", this.transceivers[t3].bufferCandidates), i2;
          }, u.prototype._gather = function(t3, r3) {
            var i2 = this, a2 = this.transceivers[r3].iceGatherer;
            if (!a2.onlocalcandidate) {
              var o2 = this.transceivers[r3].bufferedCandidateEvents;
              this.transceivers[r3].bufferedCandidateEvents = null, a2.removeEventListener("localcandidate", this.transceivers[r3].bufferCandidates), a2.onlocalcandidate = function(e3) {
                if (!(i2.usingBundle && r3 > 0)) {
                  var o3 = new Event("icecandidate");
                  o3.candidate = { sdpMid: t3, sdpMLineIndex: r3 };
                  var s2 = e3.candidate, c2 = !s2 || 0 === Object.keys(s2).length;
                  if (c2) "new" !== a2.state && "gathering" !== a2.state || (a2.state = "completed");
                  else {
                    "new" === a2.state && (a2.state = "gathering"), s2.component = 1, s2.ufrag = a2.getLocalParameters().usernameFragment;
                    var d2 = n.writeCandidate(s2);
                    o3.candidate = Object.assign(o3.candidate, n.parseCandidate(d2)), o3.candidate.candidate = d2, o3.candidate.toJSON = function() {
                      return { candidate: o3.candidate.candidate, sdpMid: o3.candidate.sdpMid, sdpMLineIndex: o3.candidate.sdpMLineIndex, usernameFragment: o3.candidate.usernameFragment };
                    };
                  }
                  var u2 = n.getMediaSections(i2._localDescription.sdp);
                  u2[o3.candidate.sdpMLineIndex] += c2 ? "a=end-of-candidates\r\n" : "a=" + o3.candidate.candidate + "\r\n", i2._localDescription.sdp = n.getDescription(i2._localDescription.sdp) + u2.join("");
                  var l2 = i2.transceivers.every(function(e4) {
                    return e4.iceGatherer && "completed" === e4.iceGatherer.state;
                  });
                  "gathering" !== i2.iceGatheringState && (i2.iceGatheringState = "gathering", i2._emitGatheringStateChange()), c2 || i2._dispatchEvent("icecandidate", o3), l2 && (i2._dispatchEvent("icecandidate", new Event("icecandidate")), i2.iceGatheringState = "complete", i2._emitGatheringStateChange());
                }
              }, e2.setTimeout(function() {
                o2.forEach(function(e3) {
                  a2.onlocalcandidate(e3);
                });
              }, 0);
            }
          }, u.prototype._createIceAndDtlsTransports = function() {
            var t3 = this, r3 = new e2.RTCIceTransport(null);
            r3.onicestatechange = function() {
              t3._updateIceConnectionState(), t3._updateConnectionState();
            };
            var n2 = new e2.RTCDtlsTransport(r3);
            return n2.ondtlsstatechange = function() {
              t3._updateConnectionState();
            }, n2.onerror = function() {
              Object.defineProperty(n2, "state", { value: "failed", writable: true }), t3._updateConnectionState();
            }, { iceTransport: r3, dtlsTransport: n2 };
          }, u.prototype._disposeIceAndDtlsTransports = function(e3) {
            var t3 = this.transceivers[e3].iceGatherer;
            t3 && (delete t3.onlocalcandidate, delete this.transceivers[e3].iceGatherer);
            var r3 = this.transceivers[e3].iceTransport;
            r3 && (delete r3.onicestatechange, delete this.transceivers[e3].iceTransport);
            var n2 = this.transceivers[e3].dtlsTransport;
            n2 && (delete n2.ondtlsstatechange, delete n2.onerror, delete this.transceivers[e3].dtlsTransport);
          }, u.prototype._transceive = function(e3, r3, i2) {
            var o2 = a(e3.localCapabilities, e3.remoteCapabilities);
            r3 && e3.rtpSender && (o2.encodings = e3.sendEncodingParameters, o2.rtcp = { cname: n.localCName, compound: e3.rtcpParameters.compound }, e3.recvEncodingParameters.length && (o2.rtcp.ssrc = e3.recvEncodingParameters[0].ssrc), e3.rtpSender.send(o2)), i2 && e3.rtpReceiver && o2.codecs.length > 0 && ("video" === e3.kind && e3.recvEncodingParameters && t2 < 15019 && e3.recvEncodingParameters.forEach(function(e4) {
              delete e4.rtx;
            }), e3.recvEncodingParameters.length ? o2.encodings = e3.recvEncodingParameters : o2.encodings = [{}], o2.rtcp = { compound: e3.rtcpParameters.compound }, e3.rtcpParameters.cname && (o2.rtcp.cname = e3.rtcpParameters.cname), e3.sendEncodingParameters.length && (o2.rtcp.ssrc = e3.sendEncodingParameters[0].ssrc), e3.rtpReceiver.receive(o2));
          }, u.prototype.setLocalDescription = function(e3) {
            var t3, r3, i2 = this;
            if (-1 === ["offer", "answer"].indexOf(e3.type)) return Promise.reject(c("TypeError", 'Unsupported type "' + e3.type + '"'));
            if (!o("setLocalDescription", e3.type, i2.signalingState) || i2._isClosed) return Promise.reject(c("InvalidStateError", "Can not set local " + e3.type + " in state " + i2.signalingState));
            if ("offer" === e3.type) t3 = n.splitSections(e3.sdp), r3 = t3.shift(), t3.forEach(function(e4, t4) {
              var r4 = n.parseRtpParameters(e4);
              i2.transceivers[t4].localCapabilities = r4;
            }), i2.transceivers.forEach(function(e4, t4) {
              i2._gather(e4.mid, t4);
            });
            else if ("answer" === e3.type) {
              t3 = n.splitSections(i2._remoteDescription.sdp), r3 = t3.shift();
              var s2 = n.matchPrefix(r3, "a=ice-lite").length > 0;
              t3.forEach(function(e4, t4) {
                var o2 = i2.transceivers[t4], c2 = o2.iceGatherer, d2 = o2.iceTransport, u2 = o2.dtlsTransport, l2 = o2.localCapabilities, p = o2.remoteCapabilities;
                if (!(n.isRejected(e4) && 0 === n.matchPrefix(e4, "a=bundle-only").length) && !o2.rejected) {
                  var f = n.getIceParameters(e4, r3), m = n.getDtlsParameters(e4, r3);
                  s2 && (m.role = "server"), i2.usingBundle && 0 !== t4 || (i2._gather(o2.mid, t4), "new" === d2.state && d2.start(c2, f, s2 ? "controlling" : "controlled"), "new" === u2.state && u2.start(m));
                  var v = a(l2, p);
                  i2._transceive(o2, v.codecs.length > 0, false);
                }
              });
            }
            return i2._localDescription = { type: e3.type, sdp: e3.sdp }, "offer" === e3.type ? i2._updateSignalingState("have-local-offer") : i2._updateSignalingState("stable"), Promise.resolve();
          }, u.prototype.setRemoteDescription = function(i2) {
            var u2 = this;
            if (-1 === ["offer", "answer"].indexOf(i2.type)) return Promise.reject(c("TypeError", 'Unsupported type "' + i2.type + '"'));
            if (!o("setRemoteDescription", i2.type, u2.signalingState) || u2._isClosed) return Promise.reject(c("InvalidStateError", "Can not set remote " + i2.type + " in state " + u2.signalingState));
            var l2 = {};
            u2.remoteStreams.forEach(function(e3) {
              l2[e3.id] = e3;
            });
            var p = [], f = n.splitSections(i2.sdp), m = f.shift(), v = n.matchPrefix(m, "a=ice-lite").length > 0, h = n.matchPrefix(m, "a=group:BUNDLE ").length > 0;
            u2.usingBundle = h;
            var g = n.matchPrefix(m, "a=ice-options:")[0];
            return u2.canTrickleIceCandidates = !!g && g.substr(14).split(" ").indexOf("trickle") >= 0, f.forEach(function(o2, c2) {
              var d2 = n.splitLines(o2), f2 = n.getKind(o2), g2 = n.isRejected(o2) && 0 === n.matchPrefix(o2, "a=bundle-only").length, y = d2[0].substr(2).split(" ")[2], S = n.getDirection(o2, m), C = n.parseMsid(o2), T = n.getMid(o2) || n.generateIdentifier();
              if (g2 || "application" === f2 && ("DTLS/SCTP" === y || "UDP/DTLS/SCTP" === y)) u2.transceivers[c2] = { mid: T, kind: f2, protocol: y, rejected: true };
              else {
                var b, k, w, R, P, E, D, x, _;
                !g2 && u2.transceivers[c2] && u2.transceivers[c2].rejected && (u2.transceivers[c2] = u2._createTransceiver(f2, true));
                var M, O, I = n.parseRtpParameters(o2);
                g2 || (M = n.getIceParameters(o2, m), (O = n.getDtlsParameters(o2, m)).role = "client"), D = n.parseRtpEncodingParameters(o2);
                var L = n.parseRtcpParameters(o2), A = n.matchPrefix(o2, "a=end-of-candidates", m).length > 0, j = n.matchPrefix(o2, "a=candidate:").map(function(e3) {
                  return n.parseCandidate(e3);
                }).filter(function(e3) {
                  return 1 === e3.component;
                });
                if (("offer" === i2.type || "answer" === i2.type) && !g2 && h && c2 > 0 && u2.transceivers[c2] && (u2._disposeIceAndDtlsTransports(c2), u2.transceivers[c2].iceGatherer = u2.transceivers[0].iceGatherer, u2.transceivers[c2].iceTransport = u2.transceivers[0].iceTransport, u2.transceivers[c2].dtlsTransport = u2.transceivers[0].dtlsTransport, u2.transceivers[c2].rtpSender && u2.transceivers[c2].rtpSender.setTransport(u2.transceivers[0].dtlsTransport), u2.transceivers[c2].rtpReceiver && u2.transceivers[c2].rtpReceiver.setTransport(u2.transceivers[0].dtlsTransport)), "offer" !== i2.type || g2) {
                  if ("answer" === i2.type && !g2) {
                    k = (b = u2.transceivers[c2]).iceGatherer, w = b.iceTransport, R = b.dtlsTransport, P = b.rtpReceiver, E = b.sendEncodingParameters, x = b.localCapabilities, u2.transceivers[c2].recvEncodingParameters = D, u2.transceivers[c2].remoteCapabilities = I, u2.transceivers[c2].rtcpParameters = L, j.length && "new" === w.state && (!v && !A || h && 0 !== c2 ? j.forEach(function(e3) {
                      s(b.iceTransport, e3);
                    }) : w.setRemoteCandidates(j)), h && 0 !== c2 || ("new" === w.state && w.start(k, M, "controlling"), "new" === R.state && R.start(O)), !a(b.localCapabilities, b.remoteCapabilities).codecs.filter(function(e3) {
                      return "rtx" === e3.name.toLowerCase();
                    }).length && b.sendEncodingParameters[0].rtx && delete b.sendEncodingParameters[0].rtx, u2._transceive(b, "sendrecv" === S || "recvonly" === S, "sendrecv" === S || "sendonly" === S), !P || "sendrecv" !== S && "sendonly" !== S ? delete b.rtpReceiver : (_ = P.track, C ? (l2[C.stream] || (l2[C.stream] = new e2.MediaStream()), r2(_, l2[C.stream]), p.push([_, P, l2[C.stream]])) : (l2.default || (l2.default = new e2.MediaStream()), r2(_, l2.default), p.push([_, P, l2.default])));
                  }
                } else {
                  (b = u2.transceivers[c2] || u2._createTransceiver(f2)).mid = T, b.iceGatherer || (b.iceGatherer = u2._createIceGatherer(c2, h)), j.length && "new" === b.iceTransport.state && (!A || h && 0 !== c2 ? j.forEach(function(e3) {
                    s(b.iceTransport, e3);
                  }) : b.iceTransport.setRemoteCandidates(j)), x = e2.RTCRtpReceiver.getCapabilities(f2), t2 < 15019 && (x.codecs = x.codecs.filter(function(e3) {
                    return "rtx" !== e3.name;
                  })), E = b.sendEncodingParameters || [{ ssrc: 1001 * (2 * c2 + 2) }];
                  var N, G = false;
                  if ("sendrecv" === S || "sendonly" === S) {
                    if (G = !b.rtpReceiver, P = b.rtpReceiver || new e2.RTCRtpReceiver(b.dtlsTransport, f2), G) _ = P.track, C && "-" === C.stream || (C ? (l2[C.stream] || (l2[C.stream] = new e2.MediaStream(), Object.defineProperty(l2[C.stream], "id", { get: function() {
                      return C.stream;
                    } })), Object.defineProperty(_, "id", { get: function() {
                      return C.track;
                    } }), N = l2[C.stream]) : (l2.default || (l2.default = new e2.MediaStream()), N = l2.default)), N && (r2(_, N), b.associatedRemoteMediaStreams.push(N)), p.push([_, P, N]);
                  } else b.rtpReceiver && b.rtpReceiver.track && (b.associatedRemoteMediaStreams.forEach(function(t3) {
                    var r3 = t3.getTracks().find(function(e3) {
                      return e3.id === b.rtpReceiver.track.id;
                    });
                    r3 && function(t4, r4) {
                      r4.removeTrack(t4), r4.dispatchEvent(new e2.MediaStreamTrackEvent("removetrack", { track: t4 }));
                    }(r3, t3);
                  }), b.associatedRemoteMediaStreams = []);
                  b.localCapabilities = x, b.remoteCapabilities = I, b.rtpReceiver = P, b.rtcpParameters = L, b.sendEncodingParameters = E, b.recvEncodingParameters = D, u2._transceive(u2.transceivers[c2], false, G);
                }
              }
            }), void 0 === u2._dtlsRole && (u2._dtlsRole = "offer" === i2.type ? "active" : "passive"), u2._remoteDescription = { type: i2.type, sdp: i2.sdp }, "offer" === i2.type ? u2._updateSignalingState("have-remote-offer") : u2._updateSignalingState("stable"), Object.keys(l2).forEach(function(t3) {
              var r3 = l2[t3];
              if (r3.getTracks().length) {
                if (-1 === u2.remoteStreams.indexOf(r3)) {
                  u2.remoteStreams.push(r3);
                  var n2 = new Event("addstream");
                  n2.stream = r3, e2.setTimeout(function() {
                    u2._dispatchEvent("addstream", n2);
                  });
                }
                p.forEach(function(e3) {
                  var t4 = e3[0], n3 = e3[1];
                  r3.id === e3[2].id && d(u2, t4, n3, [r3]);
                });
              }
            }), p.forEach(function(e3) {
              e3[2] || d(u2, e3[0], e3[1], []);
            }), e2.setTimeout(function() {
              u2 && u2.transceivers && u2.transceivers.forEach(function(e3) {
                e3.iceTransport && "new" === e3.iceTransport.state && e3.iceTransport.getRemoteCandidates().length > 0 && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), e3.iceTransport.addRemoteCandidate({}));
              });
            }, 4e3), Promise.resolve();
          }, u.prototype.close = function() {
            this.transceivers.forEach(function(e3) {
              e3.iceTransport && e3.iceTransport.stop(), e3.dtlsTransport && e3.dtlsTransport.stop(), e3.rtpSender && e3.rtpSender.stop(), e3.rtpReceiver && e3.rtpReceiver.stop();
            }), this._isClosed = true, this._updateSignalingState("closed");
          }, u.prototype._updateSignalingState = function(e3) {
            this.signalingState = e3;
            var t3 = new Event("signalingstatechange");
            this._dispatchEvent("signalingstatechange", t3);
          }, u.prototype._maybeFireNegotiationNeeded = function() {
            var t3 = this;
            "stable" === this.signalingState && true !== this.needNegotiation && (this.needNegotiation = true, e2.setTimeout(function() {
              if (t3.needNegotiation) {
                t3.needNegotiation = false;
                var e3 = new Event("negotiationneeded");
                t3._dispatchEvent("negotiationneeded", e3);
              }
            }, 0));
          }, u.prototype._updateIceConnectionState = function() {
            var e3, t3 = { new: 0, closed: 0, checking: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 };
            if (this.transceivers.forEach(function(e4) {
              e4.iceTransport && !e4.rejected && t3[e4.iceTransport.state]++;
            }), e3 = "new", t3.failed > 0 ? e3 = "failed" : t3.checking > 0 ? e3 = "checking" : t3.disconnected > 0 ? e3 = "disconnected" : t3.new > 0 ? e3 = "new" : t3.connected > 0 ? e3 = "connected" : t3.completed > 0 && (e3 = "completed"), e3 !== this.iceConnectionState) {
              this.iceConnectionState = e3;
              var r3 = new Event("iceconnectionstatechange");
              this._dispatchEvent("iceconnectionstatechange", r3);
            }
          }, u.prototype._updateConnectionState = function() {
            var e3, t3 = { new: 0, closed: 0, connecting: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 };
            if (this.transceivers.forEach(function(e4) {
              e4.iceTransport && e4.dtlsTransport && !e4.rejected && (t3[e4.iceTransport.state]++, t3[e4.dtlsTransport.state]++);
            }), t3.connected += t3.completed, e3 = "new", t3.failed > 0 ? e3 = "failed" : t3.connecting > 0 ? e3 = "connecting" : t3.disconnected > 0 ? e3 = "disconnected" : t3.new > 0 ? e3 = "new" : t3.connected > 0 && (e3 = "connected"), e3 !== this.connectionState) {
              this.connectionState = e3;
              var r3 = new Event("connectionstatechange");
              this._dispatchEvent("connectionstatechange", r3);
            }
          }, u.prototype.createOffer = function() {
            var r3 = this;
            if (r3._isClosed) return Promise.reject(c("InvalidStateError", "Can not call createOffer after close"));
            var a2 = r3.transceivers.filter(function(e3) {
              return "audio" === e3.kind;
            }).length, o2 = r3.transceivers.filter(function(e3) {
              return "video" === e3.kind;
            }).length, s2 = arguments[0];
            if (s2) {
              if (s2.mandatory || s2.optional) throw new TypeError("Legacy mandatory/optional constraints not supported.");
              void 0 !== s2.offerToReceiveAudio && (a2 = true === s2.offerToReceiveAudio ? 1 : false === s2.offerToReceiveAudio ? 0 : s2.offerToReceiveAudio), void 0 !== s2.offerToReceiveVideo && (o2 = true === s2.offerToReceiveVideo ? 1 : false === s2.offerToReceiveVideo ? 0 : s2.offerToReceiveVideo);
            }
            for (r3.transceivers.forEach(function(e3) {
              "audio" === e3.kind ? --a2 < 0 && (e3.wantReceive = false) : "video" === e3.kind && --o2 < 0 && (e3.wantReceive = false);
            }); a2 > 0 || o2 > 0; ) a2 > 0 && (r3._createTransceiver("audio"), a2--), o2 > 0 && (r3._createTransceiver("video"), o2--);
            var d2 = n.writeSessionBoilerplate(r3._sdpSessionId, r3._sdpSessionVersion++);
            r3.transceivers.forEach(function(i2, a3) {
              var o3 = i2.track, s3 = i2.kind, c2 = i2.mid || n.generateIdentifier();
              i2.mid = c2, i2.iceGatherer || (i2.iceGatherer = r3._createIceGatherer(a3, r3.usingBundle));
              var d3 = e2.RTCRtpSender.getCapabilities(s3);
              t2 < 15019 && (d3.codecs = d3.codecs.filter(function(e3) {
                return "rtx" !== e3.name;
              })), d3.codecs.forEach(function(e3) {
                "H264" === e3.name && void 0 === e3.parameters["level-asymmetry-allowed"] && (e3.parameters["level-asymmetry-allowed"] = "1"), i2.remoteCapabilities && i2.remoteCapabilities.codecs && i2.remoteCapabilities.codecs.forEach(function(t3) {
                  e3.name.toLowerCase() === t3.name.toLowerCase() && e3.clockRate === t3.clockRate && (e3.preferredPayloadType = t3.payloadType);
                });
              }), d3.headerExtensions.forEach(function(e3) {
                (i2.remoteCapabilities && i2.remoteCapabilities.headerExtensions || []).forEach(function(t3) {
                  e3.uri === t3.uri && (e3.id = t3.id);
                });
              });
              var u3 = i2.sendEncodingParameters || [{ ssrc: 1001 * (2 * a3 + 1) }];
              o3 && t2 >= 15019 && "video" === s3 && !u3[0].rtx && (u3[0].rtx = { ssrc: u3[0].ssrc + 1 }), i2.wantReceive && (i2.rtpReceiver = new e2.RTCRtpReceiver(i2.dtlsTransport, s3)), i2.localCapabilities = d3, i2.sendEncodingParameters = u3;
            }), "max-compat" !== r3._config.bundlePolicy && (d2 += "a=group:BUNDLE " + r3.transceivers.map(function(e3) {
              return e3.mid;
            }).join(" ") + "\r\n"), d2 += "a=ice-options:trickle\r\n", r3.transceivers.forEach(function(e3, t3) {
              d2 += i(e3, e3.localCapabilities, "offer", e3.stream, r3._dtlsRole), d2 += "a=rtcp-rsize\r\n", !e3.iceGatherer || "new" === r3.iceGatheringState || 0 !== t3 && r3.usingBundle || (e3.iceGatherer.getLocalCandidates().forEach(function(e4) {
                e4.component = 1, d2 += "a=" + n.writeCandidate(e4) + "\r\n";
              }), "completed" === e3.iceGatherer.state && (d2 += "a=end-of-candidates\r\n"));
            });
            var u2 = new e2.RTCSessionDescription({ type: "offer", sdp: d2 });
            return Promise.resolve(u2);
          }, u.prototype.createAnswer = function() {
            var r3 = this;
            if (r3._isClosed) return Promise.reject(c("InvalidStateError", "Can not call createAnswer after close"));
            if ("have-remote-offer" !== r3.signalingState && "have-local-pranswer" !== r3.signalingState) return Promise.reject(c("InvalidStateError", "Can not call createAnswer in signalingState " + r3.signalingState));
            var o2 = n.writeSessionBoilerplate(r3._sdpSessionId, r3._sdpSessionVersion++);
            r3.usingBundle && (o2 += "a=group:BUNDLE " + r3.transceivers.map(function(e3) {
              return e3.mid;
            }).join(" ") + "\r\n"), o2 += "a=ice-options:trickle\r\n";
            var s2 = n.getMediaSections(r3._remoteDescription.sdp).length;
            r3.transceivers.forEach(function(e3, n2) {
              if (!(n2 + 1 > s2)) {
                if (e3.rejected) return "application" === e3.kind ? "DTLS/SCTP" === e3.protocol ? o2 += "m=application 0 DTLS/SCTP 5000\r\n" : o2 += "m=application 0 " + e3.protocol + " webrtc-datachannel\r\n" : "audio" === e3.kind ? o2 += "m=audio 0 UDP/TLS/RTP/SAVPF 0\r\na=rtpmap:0 PCMU/8000\r\n" : "video" === e3.kind && (o2 += "m=video 0 UDP/TLS/RTP/SAVPF 120\r\na=rtpmap:120 VP8/90000\r\n"), void (o2 += "c=IN IP4 0.0.0.0\r\na=inactive\r\na=mid:" + e3.mid + "\r\n");
                var c2;
                if (e3.stream) "audio" === e3.kind ? c2 = e3.stream.getAudioTracks()[0] : "video" === e3.kind && (c2 = e3.stream.getVideoTracks()[0]), c2 && t2 >= 15019 && "video" === e3.kind && !e3.sendEncodingParameters[0].rtx && (e3.sendEncodingParameters[0].rtx = { ssrc: e3.sendEncodingParameters[0].ssrc + 1 });
                var d3 = a(e3.localCapabilities, e3.remoteCapabilities);
                !d3.codecs.filter(function(e4) {
                  return "rtx" === e4.name.toLowerCase();
                }).length && e3.sendEncodingParameters[0].rtx && delete e3.sendEncodingParameters[0].rtx, o2 += i(e3, d3, "answer", e3.stream, r3._dtlsRole), e3.rtcpParameters && e3.rtcpParameters.reducedSize && (o2 += "a=rtcp-rsize\r\n");
              }
            });
            var d2 = new e2.RTCSessionDescription({ type: "answer", sdp: o2 });
            return Promise.resolve(d2);
          }, u.prototype.addIceCandidate = function(e3) {
            var t3, r3 = this;
            return e3 && void 0 === e3.sdpMLineIndex && !e3.sdpMid ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise(function(i2, a2) {
              if (!r3._remoteDescription) return a2(c("InvalidStateError", "Can not add ICE candidate without a remote description"));
              if (e3 && "" !== e3.candidate) {
                var o2 = e3.sdpMLineIndex;
                if (e3.sdpMid) {
                  for (var d2 = 0; d2 < r3.transceivers.length; d2++) if (r3.transceivers[d2].mid === e3.sdpMid) {
                    o2 = d2;
                    break;
                  }
                }
                var u2 = r3.transceivers[o2];
                if (!u2) return a2(c("OperationError", "Can not add ICE candidate"));
                if (u2.rejected) return i2();
                var l2 = Object.keys(e3.candidate).length > 0 ? n.parseCandidate(e3.candidate) : {};
                if ("tcp" === l2.protocol && (0 === l2.port || 9 === l2.port)) return i2();
                if (l2.component && 1 !== l2.component) return i2();
                if ((0 === o2 || o2 > 0 && u2.iceTransport !== r3.transceivers[0].iceTransport) && !s(u2.iceTransport, l2)) return a2(c("OperationError", "Can not add ICE candidate"));
                var p = e3.candidate.trim();
                0 === p.indexOf("a=") && (p = p.substr(2)), (t3 = n.getMediaSections(r3._remoteDescription.sdp))[o2] += "a=" + (l2.type ? p : "end-of-candidates") + "\r\n", r3._remoteDescription.sdp = n.getDescription(r3._remoteDescription.sdp) + t3.join("");
              } else for (var f = 0; f < r3.transceivers.length && (r3.transceivers[f].rejected || (r3.transceivers[f].iceTransport.addRemoteCandidate({}), (t3 = n.getMediaSections(r3._remoteDescription.sdp))[f] += "a=end-of-candidates\r\n", r3._remoteDescription.sdp = n.getDescription(r3._remoteDescription.sdp) + t3.join(""), !r3.usingBundle)); f++) ;
              i2();
            });
          }, u.prototype.getStats = function(t3) {
            if (t3 && t3 instanceof e2.MediaStreamTrack) {
              var r3 = null;
              if (this.transceivers.forEach(function(e3) {
                e3.rtpSender && e3.rtpSender.track === t3 ? r3 = e3.rtpSender : e3.rtpReceiver && e3.rtpReceiver.track === t3 && (r3 = e3.rtpReceiver);
              }), !r3) throw c("InvalidAccessError", "Invalid selector.");
              return r3.getStats();
            }
            var n2 = [];
            return this.transceivers.forEach(function(e3) {
              ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach(function(t4) {
                e3[t4] && n2.push(e3[t4].getStats());
              });
            }), Promise.all(n2).then(function(e3) {
              var t4 = /* @__PURE__ */ new Map();
              return e3.forEach(function(e4) {
                e4.forEach(function(e5) {
                  t4.set(e5.id, e5);
                });
              }), t4;
            });
          };
          ["RTCRtpSender", "RTCRtpReceiver", "RTCIceGatherer", "RTCIceTransport", "RTCDtlsTransport"].forEach(function(t3) {
            var r3 = e2[t3];
            if (r3 && r3.prototype && r3.prototype.getStats) {
              var n2 = r3.prototype.getStats;
              r3.prototype.getStats = function() {
                return n2.apply(this).then(function(e3) {
                  var t4 = /* @__PURE__ */ new Map();
                  return Object.keys(e3).forEach(function(r4) {
                    var n3;
                    e3[r4].type = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[(n3 = e3[r4]).type] || n3.type, t4.set(r4, e3[r4]);
                  }), t4;
                });
              };
            }
          });
          var l = ["createOffer", "createAnswer"];
          return l.forEach(function(e3) {
            var t3 = u.prototype[e3];
            u.prototype[e3] = function() {
              var e4 = arguments;
              return "function" == typeof e4[0] || "function" == typeof e4[1] ? t3.apply(this, [arguments[2]]).then(function(t4) {
                "function" == typeof e4[0] && e4[0].apply(null, [t4]);
              }, function(t4) {
                "function" == typeof e4[1] && e4[1].apply(null, [t4]);
              }) : t3.apply(this, arguments);
            };
          }), (l = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"]).forEach(function(e3) {
            var t3 = u.prototype[e3];
            u.prototype[e3] = function() {
              var e4 = arguments;
              return "function" == typeof e4[1] || "function" == typeof e4[2] ? t3.apply(this, arguments).then(function() {
                "function" == typeof e4[1] && e4[1].apply(null);
              }, function(t4) {
                "function" == typeof e4[2] && e4[2].apply(null, [t4]);
              }) : t3.apply(this, arguments);
            };
          }), ["getStats"].forEach(function(e3) {
            var t3 = u.prototype[e3];
            u.prototype[e3] = function() {
              var e4 = arguments;
              return "function" == typeof e4[1] ? t3.apply(this, arguments).then(function() {
                "function" == typeof e4[1] && e4[1].apply(null);
              }) : t3.apply(this, arguments);
            };
          }), u;
        };
      }, function(e, t, r) {
        "use strict";
        e.exports = function(e2) {
          var t2 = e2 && e2.navigator, r2 = t2.mediaDevices.getUserMedia.bind(t2.mediaDevices);
          t2.mediaDevices.getUserMedia = function(e3) {
            return r2(e3).catch(function(e4) {
              return Promise.reject(function(e5) {
                return { name: { PermissionDeniedError: "NotAllowedError" }[e5.name] || e5.name, message: e5.message, constraint: e5.constraint, toString: function() {
                  return this.name;
                } };
              }(e4));
            });
          };
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(1);
        e.exports = { shimGetUserMedia: r(14), shimOnTrack: function(e2) {
          "object" == typeof e2 && e2.RTCPeerConnection && !("ontrack" in e2.RTCPeerConnection.prototype) && Object.defineProperty(e2.RTCPeerConnection.prototype, "ontrack", { get: function() {
            return this._ontrack;
          }, set: function(e3) {
            this._ontrack && (this.removeEventListener("track", this._ontrack), this.removeEventListener("addstream", this._ontrackpoly)), this.addEventListener("track", this._ontrack = e3), this.addEventListener("addstream", this._ontrackpoly = (function(e4) {
              e4.stream.getTracks().forEach((function(t2) {
                var r2 = new Event("track");
                r2.track = t2, r2.receiver = { track: t2 }, r2.transceiver = { receiver: r2.receiver }, r2.streams = [e4.stream], this.dispatchEvent(r2);
              }).bind(this));
            }).bind(this));
          }, enumerable: true, configurable: true }), "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get: function() {
            return { receiver: this.receiver };
          } });
        }, shimSourceObject: function(e2) {
          "object" == typeof e2 && e2.HTMLMediaElement && !("srcObject" in e2.HTMLMediaElement.prototype) && Object.defineProperty(e2.HTMLMediaElement.prototype, "srcObject", { get: function() {
            return this.mozSrcObject;
          }, set: function(e3) {
            this.mozSrcObject = e3;
          } });
        }, shimPeerConnection: function(e2) {
          var t2 = n.detectBrowser(e2);
          if ("object" == typeof e2 && (e2.RTCPeerConnection || e2.mozRTCPeerConnection)) {
            e2.RTCPeerConnection || (e2.RTCPeerConnection = function(r3, n2) {
              if (t2.version < 38 && r3 && r3.iceServers) {
                for (var i2 = [], a2 = 0; a2 < r3.iceServers.length; a2++) {
                  var o = r3.iceServers[a2];
                  if (o.hasOwnProperty("urls")) for (var s = 0; s < o.urls.length; s++) {
                    var c = { url: o.urls[s] };
                    0 === o.urls[s].indexOf("turn") && (c.username = o.username, c.credential = o.credential), i2.push(c);
                  }
                  else i2.push(r3.iceServers[a2]);
                }
                r3.iceServers = i2;
              }
              return new e2.mozRTCPeerConnection(r3, n2);
            }, e2.RTCPeerConnection.prototype = e2.mozRTCPeerConnection.prototype, e2.mozRTCPeerConnection.generateCertificate && Object.defineProperty(e2.RTCPeerConnection, "generateCertificate", { get: function() {
              return e2.mozRTCPeerConnection.generateCertificate;
            } }), e2.RTCSessionDescription = e2.mozRTCSessionDescription, e2.RTCIceCandidate = e2.mozRTCIceCandidate), ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
              var r3 = e2.RTCPeerConnection.prototype[t3];
              e2.RTCPeerConnection.prototype[t3] = function() {
                return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), r3.apply(this, arguments);
              };
            });
            var r2 = e2.RTCPeerConnection.prototype.addIceCandidate;
            e2.RTCPeerConnection.prototype.addIceCandidate = function() {
              return arguments[0] ? r2.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
            };
            var i = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, a = e2.RTCPeerConnection.prototype.getStats;
            e2.RTCPeerConnection.prototype.getStats = function(e3, r3, n2) {
              return a.apply(this, [e3 || null]).then(function(e4) {
                if (t2.version < 48 && (e4 = function(e5) {
                  var t3 = /* @__PURE__ */ new Map();
                  return Object.keys(e5).forEach(function(r4) {
                    t3.set(r4, e5[r4]), t3[r4] = e5[r4];
                  }), t3;
                }(e4)), t2.version < 53 && !r3) try {
                  e4.forEach(function(e5) {
                    e5.type = i[e5.type] || e5.type;
                  });
                } catch (t3) {
                  if ("TypeError" !== t3.name) throw t3;
                  e4.forEach(function(t4, r4) {
                    e4.set(r4, Object.assign({}, t4, { type: i[t4.type] || t4.type }));
                  });
                }
                return e4;
              }).then(r3, n2);
            };
          }
        }, shimSenderGetStats: function(e2) {
          if ("object" == typeof e2 && e2.RTCPeerConnection && e2.RTCRtpSender && (!e2.RTCRtpSender || !("getStats" in e2.RTCRtpSender.prototype))) {
            var t2 = e2.RTCPeerConnection.prototype.getSenders;
            t2 && (e2.RTCPeerConnection.prototype.getSenders = function() {
              var e3 = this, r3 = t2.apply(e3, []);
              return r3.forEach(function(t3) {
                t3._pc = e3;
              }), r3;
            });
            var r2 = e2.RTCPeerConnection.prototype.addTrack;
            r2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
              var e3 = r2.apply(this, arguments);
              return e3._pc = this, e3;
            }), e2.RTCRtpSender.prototype.getStats = function() {
              return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
            };
          }
        }, shimReceiverGetStats: function(e2) {
          if ("object" == typeof e2 && e2.RTCPeerConnection && e2.RTCRtpSender && (!e2.RTCRtpSender || !("getStats" in e2.RTCRtpReceiver.prototype))) {
            var t2 = e2.RTCPeerConnection.prototype.getReceivers;
            t2 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
              var e3 = this, r2 = t2.apply(e3, []);
              return r2.forEach(function(t3) {
                t3._pc = e3;
              }), r2;
            }), n.wrapPeerConnectionEvent(e2, "track", function(e3) {
              return e3.receiver._pc = e3.srcElement, e3;
            }), e2.RTCRtpReceiver.prototype.getStats = function() {
              return this._pc.getStats(this.track);
            };
          }
        }, shimRemoveStream: function(e2) {
          e2.RTCPeerConnection && !("removeStream" in e2.RTCPeerConnection.prototype) && (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            var t2 = this;
            n.deprecated("removeStream", "removeTrack"), this.getSenders().forEach(function(r2) {
              r2.track && -1 !== e3.getTracks().indexOf(r2.track) && t2.removeTrack(r2);
            });
          });
        }, shimRTCDataChannel: function(e2) {
          e2.DataChannel && !e2.RTCDataChannel && (e2.RTCDataChannel = e2.DataChannel);
        }, shimGetDisplayMedia: function(e2, t2) {
          e2.navigator && e2.navigator.mediaDevices && !("getDisplayMedia" in e2.navigator.mediaDevices) && (e2.navigator.mediaDevices.getDisplayMedia = function(r2) {
            if (!r2 || !r2.video) {
              var n2 = new DOMException("getDisplayMedia without video constraints is undefined");
              return n2.name = "NotFoundError", n2.code = 8, Promise.reject(n2);
            }
            return true === r2.video ? r2.video = { mediaSource: t2 } : r2.video.mediaSource = t2, e2.navigator.mediaDevices.getUserMedia(r2);
          }, e2.navigator.getDisplayMedia = function(t3) {
            return n.deprecated("navigator.getDisplayMedia", "navigator.mediaDevices.getDisplayMedia"), e2.navigator.mediaDevices.getDisplayMedia(t3);
          });
        } };
      }, function(e, t, r) {
        "use strict";
        var n = r(1), i = n.log;
        e.exports = function(e2) {
          var t2 = n.detectBrowser(e2), r2 = e2 && e2.navigator, a = e2 && e2.MediaStreamTrack, o = function(e3) {
            return { name: { InternalError: "NotReadableError", NotSupportedError: "TypeError", PermissionDeniedError: "NotAllowedError", SecurityError: "NotAllowedError" }[e3.name] || e3.name, message: { "The operation is insecure.": "The request is not allowed by the user agent or the platform in the current context." }[e3.message] || e3.message, constraint: e3.constraint, toString: function() {
              return this.name + (this.message && ": ") + this.message;
            } };
          }, s = function(e3, n2, a2) {
            var s2 = function(e4) {
              if ("object" != typeof e4 || e4.require) return e4;
              var t3 = [];
              return Object.keys(e4).forEach(function(r3) {
                if ("require" !== r3 && "advanced" !== r3 && "mediaSource" !== r3) {
                  var n3 = e4[r3] = "object" == typeof e4[r3] ? e4[r3] : { ideal: e4[r3] };
                  if (void 0 === n3.min && void 0 === n3.max && void 0 === n3.exact || t3.push(r3), void 0 !== n3.exact && ("number" == typeof n3.exact ? n3.min = n3.max = n3.exact : e4[r3] = n3.exact, delete n3.exact), void 0 !== n3.ideal) {
                    e4.advanced = e4.advanced || [];
                    var i2 = {};
                    "number" == typeof n3.ideal ? i2[r3] = { min: n3.ideal, max: n3.ideal } : i2[r3] = n3.ideal, e4.advanced.push(i2), delete n3.ideal, Object.keys(n3).length || delete e4[r3];
                  }
                }
              }), t3.length && (e4.require = t3), e4;
            };
            return e3 = JSON.parse(JSON.stringify(e3)), t2.version < 38 && (i("spec: " + JSON.stringify(e3)), e3.audio && (e3.audio = s2(e3.audio)), e3.video && (e3.video = s2(e3.video)), i("ff37: " + JSON.stringify(e3))), r2.mozGetUserMedia(e3, n2, function(e4) {
              a2(o(e4));
            });
          };
          if (r2.mediaDevices || (r2.mediaDevices = { getUserMedia: function(e3) {
            return new Promise(function(t3, r3) {
              s(e3, t3, r3);
            });
          }, addEventListener: function() {
          }, removeEventListener: function() {
          } }), r2.mediaDevices.enumerateDevices = r2.mediaDevices.enumerateDevices || function() {
            return new Promise(function(e3) {
              e3([{ kind: "audioinput", deviceId: "default", label: "", groupId: "" }, { kind: "videoinput", deviceId: "default", label: "", groupId: "" }]);
            });
          }, t2.version < 41) {
            var c = r2.mediaDevices.enumerateDevices.bind(r2.mediaDevices);
            r2.mediaDevices.enumerateDevices = function() {
              return c().then(void 0, function(e3) {
                if ("NotFoundError" === e3.name) return [];
                throw e3;
              });
            };
          }
          if (t2.version < 49) {
            var d = r2.mediaDevices.getUserMedia.bind(r2.mediaDevices);
            r2.mediaDevices.getUserMedia = function(e3) {
              return d(e3).then(function(t3) {
                if (e3.audio && !t3.getAudioTracks().length || e3.video && !t3.getVideoTracks().length) throw t3.getTracks().forEach(function(e4) {
                  e4.stop();
                }), new DOMException("The object can not be found here.", "NotFoundError");
                return t3;
              }, function(e4) {
                return Promise.reject(o(e4));
              });
            };
          }
          if (!(t2.version > 55 && "autoGainControl" in r2.mediaDevices.getSupportedConstraints())) {
            var u = function(e3, t3, r3) {
              t3 in e3 && !(r3 in e3) && (e3[r3] = e3[t3], delete e3[t3]);
            }, l = r2.mediaDevices.getUserMedia.bind(r2.mediaDevices);
            if (r2.mediaDevices.getUserMedia = function(e3) {
              return "object" == typeof e3 && "object" == typeof e3.audio && (e3 = JSON.parse(JSON.stringify(e3)), u(e3.audio, "autoGainControl", "mozAutoGainControl"), u(e3.audio, "noiseSuppression", "mozNoiseSuppression")), l(e3);
            }, a && a.prototype.getSettings) {
              var p = a.prototype.getSettings;
              a.prototype.getSettings = function() {
                var e3 = p.apply(this, arguments);
                return u(e3, "mozAutoGainControl", "autoGainControl"), u(e3, "mozNoiseSuppression", "noiseSuppression"), e3;
              };
            }
            if (a && a.prototype.applyConstraints) {
              var f = a.prototype.applyConstraints;
              a.prototype.applyConstraints = function(e3) {
                return "audio" === this.kind && "object" == typeof e3 && (e3 = JSON.parse(JSON.stringify(e3)), u(e3, "autoGainControl", "mozAutoGainControl"), u(e3, "noiseSuppression", "mozNoiseSuppression")), f.apply(this, [e3]);
              };
            }
          }
          r2.getUserMedia = function(e3, i2, a2) {
            if (t2.version < 44) return s(e3, i2, a2);
            n.deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), r2.mediaDevices.getUserMedia(e3).then(i2, a2);
          };
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(1);
        e.exports = { shimLocalStreamsAPI: function(e2) {
          if ("object" == typeof e2 && e2.RTCPeerConnection) {
            if ("getLocalStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getLocalStreams = function() {
              return this._localStreams || (this._localStreams = []), this._localStreams;
            }), "getStreamById" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getStreamById = function(e3) {
              var t3 = null;
              return this._localStreams && this._localStreams.forEach(function(r2) {
                r2.id === e3 && (t3 = r2);
              }), this._remoteStreams && this._remoteStreams.forEach(function(r2) {
                r2.id === e3 && (t3 = r2);
              }), t3;
            }), !("addStream" in e2.RTCPeerConnection.prototype)) {
              var t2 = e2.RTCPeerConnection.prototype.addTrack;
              e2.RTCPeerConnection.prototype.addStream = function(e3) {
                this._localStreams || (this._localStreams = []), -1 === this._localStreams.indexOf(e3) && this._localStreams.push(e3);
                var r2 = this;
                e3.getTracks().forEach(function(n2) {
                  t2.call(r2, n2, e3);
                });
              }, e2.RTCPeerConnection.prototype.addTrack = function(e3, r2) {
                return r2 && (this._localStreams ? -1 === this._localStreams.indexOf(r2) && this._localStreams.push(r2) : this._localStreams = [r2]), t2.call(this, e3, r2);
              };
            }
            "removeStream" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
              this._localStreams || (this._localStreams = []);
              var t3 = this._localStreams.indexOf(e3);
              if (-1 !== t3) {
                this._localStreams.splice(t3, 1);
                var r2 = this, n2 = e3.getTracks();
                this.getSenders().forEach(function(e4) {
                  -1 !== n2.indexOf(e4.track) && r2.removeTrack(e4);
                });
              }
            });
          }
        }, shimRemoteStreamsAPI: function(e2) {
          if ("object" == typeof e2 && e2.RTCPeerConnection && ("getRemoteStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getRemoteStreams = function() {
            return this._remoteStreams ? this._remoteStreams : [];
          }), !("onaddstream" in e2.RTCPeerConnection.prototype))) {
            Object.defineProperty(e2.RTCPeerConnection.prototype, "onaddstream", { get: function() {
              return this._onaddstream;
            }, set: function(e3) {
              this._onaddstream && this.removeEventListener("addstream", this._onaddstream), this.addEventListener("addstream", this._onaddstream = e3);
            } });
            var t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
            e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
              var e3 = this;
              return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t3) {
                t3.streams.forEach(function(t4) {
                  if (e3._remoteStreams || (e3._remoteStreams = []), !(e3._remoteStreams.indexOf(t4) >= 0)) {
                    e3._remoteStreams.push(t4);
                    var r2 = new Event("addstream");
                    r2.stream = t4, e3.dispatchEvent(r2);
                  }
                });
              }), t2.apply(e3, arguments);
            };
          }
        }, shimCallbacksAPI: function(e2) {
          if ("object" == typeof e2 && e2.RTCPeerConnection) {
            var t2 = e2.RTCPeerConnection.prototype, r2 = t2.createOffer, n2 = t2.createAnswer, i = t2.setLocalDescription, a = t2.setRemoteDescription, o = t2.addIceCandidate;
            t2.createOffer = function(e3, t3) {
              var n3 = arguments.length >= 2 ? arguments[2] : arguments[0], i2 = r2.apply(this, [n3]);
              return t3 ? (i2.then(e3, t3), Promise.resolve()) : i2;
            }, t2.createAnswer = function(e3, t3) {
              var r3 = arguments.length >= 2 ? arguments[2] : arguments[0], i2 = n2.apply(this, [r3]);
              return t3 ? (i2.then(e3, t3), Promise.resolve()) : i2;
            };
            var s = function(e3, t3, r3) {
              var n3 = i.apply(this, [e3]);
              return r3 ? (n3.then(t3, r3), Promise.resolve()) : n3;
            };
            t2.setLocalDescription = s, s = function(e3, t3, r3) {
              var n3 = a.apply(this, [e3]);
              return r3 ? (n3.then(t3, r3), Promise.resolve()) : n3;
            }, t2.setRemoteDescription = s, s = function(e3, t3, r3) {
              var n3 = o.apply(this, [e3]);
              return r3 ? (n3.then(t3, r3), Promise.resolve()) : n3;
            }, t2.addIceCandidate = s;
          }
        }, shimGetUserMedia: function(e2) {
          var t2 = e2 && e2.navigator;
          t2.getUserMedia || (t2.webkitGetUserMedia ? t2.getUserMedia = t2.webkitGetUserMedia.bind(t2) : t2.mediaDevices && t2.mediaDevices.getUserMedia && (t2.getUserMedia = (function(e3, r2, n2) {
            t2.mediaDevices.getUserMedia(e3).then(r2, n2);
          }).bind(t2)));
        }, shimRTCIceServerUrls: function(e2) {
          var t2 = e2.RTCPeerConnection;
          e2.RTCPeerConnection = function(e3, r2) {
            if (e3 && e3.iceServers) {
              for (var i = [], a = 0; a < e3.iceServers.length; a++) {
                var o = e3.iceServers[a];
                !o.hasOwnProperty("urls") && o.hasOwnProperty("url") ? (n.deprecated("RTCIceServer.url", "RTCIceServer.urls"), (o = JSON.parse(JSON.stringify(o))).urls = o.url, delete o.url, i.push(o)) : i.push(e3.iceServers[a]);
              }
              e3.iceServers = i;
            }
            return new t2(e3, r2);
          }, e2.RTCPeerConnection.prototype = t2.prototype, "generateCertificate" in e2.RTCPeerConnection && Object.defineProperty(e2.RTCPeerConnection, "generateCertificate", { get: function() {
            return t2.generateCertificate;
          } });
        }, shimTrackEventTransceiver: function(e2) {
          "object" == typeof e2 && e2.RTCPeerConnection && "receiver" in e2.RTCTrackEvent.prototype && !e2.RTCTransceiver && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get: function() {
            return { receiver: this.receiver };
          } });
        }, shimCreateOfferLegacy: function(e2) {
          var t2 = e2.RTCPeerConnection.prototype.createOffer;
          e2.RTCPeerConnection.prototype.createOffer = function(e3) {
            var r2 = this;
            if (e3) {
              void 0 !== e3.offerToReceiveAudio && (e3.offerToReceiveAudio = !!e3.offerToReceiveAudio);
              var n2 = r2.getTransceivers().find(function(e4) {
                return e4.sender.track && "audio" === e4.sender.track.kind;
              });
              false === e3.offerToReceiveAudio && n2 ? "sendrecv" === n2.direction ? n2.setDirection ? n2.setDirection("sendonly") : n2.direction = "sendonly" : "recvonly" === n2.direction && (n2.setDirection ? n2.setDirection("inactive") : n2.direction = "inactive") : true !== e3.offerToReceiveAudio || n2 || r2.addTransceiver("audio"), void 0 !== e3.offerToReceiveVideo && (e3.offerToReceiveVideo = !!e3.offerToReceiveVideo);
              var i = r2.getTransceivers().find(function(e4) {
                return e4.sender.track && "video" === e4.sender.track.kind;
              });
              false === e3.offerToReceiveVideo && i ? "sendrecv" === i.direction ? i.setDirection("sendonly") : "recvonly" === i.direction && i.setDirection("inactive") : true !== e3.offerToReceiveVideo || i || r2.addTransceiver("video");
            }
            return t2.apply(r2, arguments);
          };
        } };
      }, function(e, t, r) {
        "use strict";
        var n = r(2), i = r(1);
        e.exports = { shimRTCIceCandidate: function(e2) {
          if (!(!e2.RTCIceCandidate || e2.RTCIceCandidate && "foundation" in e2.RTCIceCandidate.prototype)) {
            var t2 = e2.RTCIceCandidate;
            e2.RTCIceCandidate = function(e3) {
              if ("object" == typeof e3 && e3.candidate && 0 === e3.candidate.indexOf("a=") && ((e3 = JSON.parse(JSON.stringify(e3))).candidate = e3.candidate.substr(2)), e3.candidate && e3.candidate.length) {
                var r2 = new t2(e3), i2 = n.parseCandidate(e3.candidate), a = Object.assign(r2, i2);
                return a.toJSON = function() {
                  return { candidate: a.candidate, sdpMid: a.sdpMid, sdpMLineIndex: a.sdpMLineIndex, usernameFragment: a.usernameFragment };
                }, a;
              }
              return new t2(e3);
            }, e2.RTCIceCandidate.prototype = t2.prototype, i.wrapPeerConnectionEvent(e2, "icecandidate", function(t3) {
              return t3.candidate && Object.defineProperty(t3, "candidate", { value: new e2.RTCIceCandidate(t3.candidate), writable: "false" }), t3;
            });
          }
        }, shimCreateObjectURL: function(e2) {
          var t2 = e2 && e2.URL;
          if ("object" == typeof e2 && e2.HTMLMediaElement && "srcObject" in e2.HTMLMediaElement.prototype && t2.createObjectURL && t2.revokeObjectURL) {
            var r2 = t2.createObjectURL.bind(t2), n2 = t2.revokeObjectURL.bind(t2), a = /* @__PURE__ */ new Map(), o = 0;
            t2.createObjectURL = function(e3) {
              if ("getTracks" in e3) {
                var t3 = "polyblob:" + ++o;
                return a.set(t3, e3), i.deprecated("URL.createObjectURL(stream)", "elem.srcObject = stream"), t3;
              }
              return r2(e3);
            }, t2.revokeObjectURL = function(e3) {
              n2(e3), a.delete(e3);
            };
            var s = Object.getOwnPropertyDescriptor(e2.HTMLMediaElement.prototype, "src");
            Object.defineProperty(e2.HTMLMediaElement.prototype, "src", { get: function() {
              return s.get.apply(this);
            }, set: function(e3) {
              return this.srcObject = a.get(e3) || null, s.set.apply(this, [e3]);
            } });
            var c = e2.HTMLMediaElement.prototype.setAttribute;
            e2.HTMLMediaElement.prototype.setAttribute = function() {
              return 2 === arguments.length && "src" === ("" + arguments[0]).toLowerCase() && (this.srcObject = a.get(arguments[1]) || null), c.apply(this, arguments);
            };
          }
        }, shimMaxMessageSize: function(e2) {
          if (!e2.RTCSctpTransport && e2.RTCPeerConnection) {
            var t2 = i.detectBrowser(e2);
            "sctp" in e2.RTCPeerConnection.prototype || Object.defineProperty(e2.RTCPeerConnection.prototype, "sctp", { get: function() {
              return void 0 === this._sctp ? null : this._sctp;
            } });
            var r2 = function(e3) {
              var t3 = n.splitSections(e3.sdp);
              return t3.shift(), t3.some(function(e4) {
                var t4 = n.parseMLine(e4);
                return t4 && "application" === t4.kind && -1 !== t4.protocol.indexOf("SCTP");
              });
            }, a = function(e3) {
              var t3 = e3.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
              if (null === t3 || t3.length < 2) return -1;
              var r3 = parseInt(t3[1], 10);
              return r3 != r3 ? -1 : r3;
            }, o = function(e3) {
              var r3 = 65536;
              return "firefox" === t2.browser && (r3 = t2.version < 57 ? -1 === e3 ? 16384 : 2147483637 : t2.version < 60 ? 57 === t2.version ? 65535 : 65536 : 2147483637), r3;
            }, s = function(e3, r3) {
              var i2 = 65536;
              "firefox" === t2.browser && 57 === t2.version && (i2 = 65535);
              var a2 = n.matchPrefix(e3.sdp, "a=max-message-size:");
              return a2.length > 0 ? i2 = parseInt(a2[0].substr(19), 10) : "firefox" === t2.browser && -1 !== r3 && (i2 = 2147483637), i2;
            }, c = e2.RTCPeerConnection.prototype.setRemoteDescription;
            e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
              var e3 = this;
              if (e3._sctp = null, r2(arguments[0])) {
                var t3, n2 = a(arguments[0]), i2 = o(n2), d = s(arguments[0], n2);
                t3 = 0 === i2 && 0 === d ? Number.POSITIVE_INFINITY : 0 === i2 || 0 === d ? Math.max(i2, d) : Math.min(i2, d);
                var u = {};
                Object.defineProperty(u, "maxMessageSize", { get: function() {
                  return t3;
                } }), e3._sctp = u;
              }
              return c.apply(e3, arguments);
            };
          }
        }, shimSendThrowTypeError: function(e2) {
          if (e2.RTCPeerConnection && "createDataChannel" in e2.RTCPeerConnection.prototype) {
            var t2 = e2.RTCPeerConnection.prototype.createDataChannel;
            e2.RTCPeerConnection.prototype.createDataChannel = function() {
              var e3 = this, n2 = t2.apply(e3, arguments);
              return r2(n2, e3), n2;
            }, i.wrapPeerConnectionEvent(e2, "datachannel", function(e3) {
              return r2(e3.channel, e3.target), e3;
            });
          }
          function r2(e3, t3) {
            var r3 = e3.send;
            e3.send = function() {
              var n2 = arguments[0], i2 = n2.length || n2.size || n2.byteLength;
              if ("open" === e3.readyState && t3.sctp && i2 > t3.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t3.sctp.maxMessageSize + " bytes)");
              return r3.apply(e3, arguments);
            };
          }
        } };
      }, function(e, t, r) {
        "use strict";
        r.r(t);
        "undefined" != typeof console && void 0 !== console.log || (console = { log: function() {
        } });
        var n = function() {
        }, i = function() {
        }, a = function() {
        }, o = function() {
        }, s = function() {
        }, c = function() {
        };
        c = console.error.bind(console);
        var d = { trace: n, debug: i, vdebug: a, log: o, warn: s, error: c }, u = r(0), l = r.n(u);
        function p(e2) {
          return (p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        var f = null, m = null, v = null, h = false, g = null, y = null, S = null, C = function(e2) {
          switch (e2.response) {
            case "keepalive":
              d.vdebug("Got a keepalive");
              break;
            case "ack":
              d.debug("Got an ack"), d.debug(e2);
              break;
            case "success":
              d.debug("Got a success"), d.debug(e2), y(e2);
              break;
            case "closed":
              d.debug("Got a closed connection"), d.debug(e2), S();
              break;
            case "offline":
              d.debug("Connection is offline, token expired"), d.debug(e2), m("offline");
              break;
            case "trickle":
              if (!G() && !U()) return void d.debug("This handle is not attached to this session");
              var t2 = e2.candidate, r2 = g.webrtcConfig;
              d.debug("Got a trickled candidate"), d.debug(t2), r2.pc && r2.remoteSdp ? (d.debug("Adding remote candidate:", t2), t2 && true !== t2.completed ? r2.pc.addIceCandidate(new RTCIceCandidate(t2)) : r2.pc.addIceCandidate()) : (d.debug("We didn't do setRemoteDescription (trickle got here before the offer?), caching candidate"), r2.candidates || (r2.candidates = []), r2.candidates.push(t2), d.debug(r2.candidates));
              break;
            case "webrtcup":
              if (!G()) return void d.debug("This handle is not attached");
              g.webrtcState(true);
              break;
            case "hangup":
              if (d.debug("Got a hangup event"), d.debug(e2), !G()) return void d.debug("This handle is not attached");
              g.webrtcState(false, e2.reason), g.hangup();
              break;
            case "media":
              if (d.debug("Got a media event"), d.debug(e2), !G()) return void d.debug("This handle is not attached");
              g.mediaState(e2.type, e2.receiving);
              break;
            case "slowlink":
              if (d.debug("Got a slowlink event"), d.debug(e2), !G()) return void d.debug("This handle is not attached");
              g.slowLink(e2.uplink, e2.nacks);
              break;
            case "error":
              d.error("AfricasTalking Client Error: " + e2.error.code + " " + e2.error.reason), d.debug(e2);
              break;
            case "event":
              if (d.log("Got an event"), d.log(e2), void 0 === e2.eventdata || null === e2.eventdata) return void d.warn("Missing eventdata...");
              if (d.log(e2.eventdata), !G()) return void d.warn("This handle is not attachedddd");
              void 0 !== e2.jsep && null !== e2.jsep && (d.log("Handling SDP as well..."), d.log(e2.jsep)), null !== g.onmessage && void 0 !== g.onmessage ? (d.log("Notifying application..."), g.onmessage(e2.eventdata, e2.jsep)) : d.debug("No provided notification callback");
              break;
            default:
              d.warn("Unknown message/event  " + e2), d.debug(e2);
          }
        }, T = function(e2) {
          if (!h) return d.warn("Is the gateway down? (connected=false)"), void e2.error("Is the gateway down? (connected=false)");
          if (!G() && !U()) return d.warn("Invalid handle"), void e2.error("Invalid handle");
          var t2 = e2.message, r2 = e2.jsep, n2 = { command: "message", body: t2 };
          null != r2 && (n2.jsep = r2), d.debug("Sending message to web socket"), d.debug(n2), d.debug("Sending a request to Africa's Talking" + n2), f.send(JSON.stringify(n2));
        }, b = function(e2) {
          if (!G() && !U()) return d.warn("Invalid handle"), void e2.error("Invalid handle");
          var t2 = g.webrtcConfig, r2 = e2.text;
          if (null == r2) return d.warn("Invalid text"), void e2.error("Invalid text");
          d.log("Sending string on data channel: " + r2), t2.dataChannel.send(r2), e2.success();
        }, k = function(e2) {
          var t2 = e2.jsep;
          e2.media = e2.media || { audio: true };
          var r2 = e2.media;
          if (!G() && !U()) return d.warn("Invalid handle"), void e2.error("Invalid handle");
          var n2 = g.webrtcConfig;
          if (void 0 === n2.pc || null === n2.pc) d.log("Creating a new media session"), r2.update = false;
          else if (void 0 !== n2.pc && null !== n2.pc) if (d.log("Updating existing media session"), r2.update = true, null !== e2.stream && void 0 !== e2.stream) e2.stream !== n2.myStream && d.log("Renegotiation involves a new external stream");
          else {
            if (r2.addAudio) {
              if (r2.replaceAudio = false, r2.removeAudio = false, r2.audioSend = true, n2.myStream && n2.myStream.getAudioTracks() && n2.myStream.getAudioTracks().length) return d.error("AfricasTalking Client Error: Can't add audio stream, there already is one"), void e2.error("AfricasTalking Client Error: Can't add audio stream, there already is one");
            } else r2.removeAudio ? (r2.replaceAudio = false, r2.addAudio = false, r2.audioSend = false) : r2.replaceAudio && (r2.addAudio = false, r2.removeAudio = false, r2.audioSend = true);
            null === n2.myStream || void 0 === n2.myStream ? (r2.replaceAudio && (r2.replaceAudio = false, r2.addAudio = true, r2.audioSend = true), L(r2) && (r2.addAudio = true)) : null !== n2.myStream.getAudioTracks() && void 0 !== n2.myStream.getAudioTracks() && 0 !== n2.myStream.getAudioTracks().length || (r2.replaceAudio && (r2.replaceAudio = false, r2.addAudio = true, r2.audioSend = true), L(r2) && (r2.addAudio = true));
          }
          if (r2.update && !n2.streamExternal && (r2.removeAudio || r2.replaceAudio)) {
            if (n2.myStream && n2.myStream.getAudioTracks() && n2.myStream.getAudioTracks().length) {
              var i2 = n2.myStream.getAudioTracks()[0];
              d.log("Removing audio track:", i2), n2.myStream.removeTrack(i2);
              try {
                i2.stop();
              } catch (e3) {
                d.log("Error removing audio track:", e3);
              }
            }
            if (n2.pc.getSenders() && n2.pc.getSenders().length && !r2.replaceAudio && "firefox" === l.a.browserDetails.browser) for (var a2 in n2.pc.getSenders()) {
              var o2 = n2.pc.getSenders()[a2];
              o2 && o2.track && "audio" === o2.track.kind && (d.log("Removing audio sender:", o2), n2.pc.removeTrack(o2));
            }
          }
          if (null !== e2.stream && void 0 !== e2.stream) {
            var s2 = e2.stream;
            if (d.log("MediaStream provided by the application"), d.debug(s2), r2.update && n2.myStream && n2.myStream !== e2.stream && !n2.streamExternal) {
              try {
                var c2 = n2.myStream.getTracks();
                for (var u2 in c2) {
                  var f2 = c2[u2];
                  d.log(f2), null != f2 && f2.stop();
                }
              } catch (e3) {
              }
              n2.myStream = null;
            }
            return n2.streamExternal = true, void D(t2, r2, e2, s2);
          }
          if (d.log("Executing isAudioSendEnabled"), L(r2)) {
            g.consentDialog(true);
            var m2 = L(r2);
            true === m2 && null != r2 && null != r2 && "object" === p(r2.audio) && (m2 = r2.audio), null != r2 && "screen" === r2.video || navigator.mediaDevices.enumerateDevices().then(function(n3) {
              var i3 = n3.some(function(e3) {
                return "audioinput" === e3.kind;
              }), a3 = L(r2), o3 = A(r2);
              if ((a3 || o3) && (!(!!a3 && i3) && o3)) return g.consentDialog(false), e2.error("Audio capture is required, but no capture device found"), false;
              var s3 = { audio: !!i3 && m2, video: false };
              d.debug("getUserMedia constraints", s3), navigator.mediaDevices.getUserMedia(s3).then(function(n4) {
                g.consentDialog(false), D(t2, r2, e2, n4);
              }).catch(function(t3) {
                g.consentDialog(false), e2.error({ code: t3.code, name: t3.name, message: t3.message });
              });
            }).catch(function(t3) {
              g.consentDialog(false), e2.error("enumerateDevices error", t3);
            });
          } else D(t2, r2, e2);
        }, w = function(e2) {
          var t2 = e2.jsep;
          if (!G() && !U()) return d.warn("Invalid handle"), void e2.error("Invalid handle");
          var r2 = g.webrtcConfig;
          if (null != t2) {
            if (null === r2.pc) return d.warn("Wait, no PeerConnection?? if this is an answer, use createAnswer and not handleRemoteJsep"), void e2.error("No PeerConnection: if this is an answer, use createAnswer and not handleRemoteJsep");
            r2.pc.setRemoteDescription(new RTCSessionDescription(t2), function() {
              if (d.log("Remote description accepted!"), r2.remoteSdp = t2.sdp, r2.candidates && r2.candidates.length > 0) {
                for (var e3 in r2.candidates) {
                  var n2 = r2.candidates[e3];
                  d.debug("Adding remote candidate:", n2), n2 && true !== n2.completed ? r2.pc.addIceCandidate(new RTCIceCandidate(n2)) : r2.pc.addIceCandidate();
                }
                r2.candidates = [];
              }
            }, e2.error);
          } else e2.error("Invalid JSEP");
        }, R = function() {
          if (!G() && !U()) return d.warn("Invalid handle"), "Invalid handle";
          var e2 = g.webrtcConfig;
          return null === e2.pc || void 0 === e2.pc ? "Invalid PeerConnection" : e2.pc.getStats ? null === e2.bitrate.timer || void 0 === e2.bitrate.timer ? (d.log("Starting bitrate timer (via getStats)"), e2.bitrate.timer = setInterval(function() {
            e2.pc.getStats().then(function(t2) {
              t2.forEach(function(t3) {
                if (t3) {
                  var r2 = false;
                  if (("video" === t3.mediaType || t3.id.toLowerCase().indexOf("video") > -1) && "inbound-rtp" === t3.type && t3.id.indexOf("rtcp") < 0 ? r2 = true : "ssrc" != t3.type || !t3.bytesReceived || "VP8" !== t3.googCodecName && "" !== t3.googCodecName || (r2 = true), r2) if (e2.bitrate.bsnow = t3.bytesReceived, e2.bitrate.tsnow = t3.timestamp, null === e2.bitrate.bsbefore || null === e2.bitrate.tsbefore) e2.bitrate.bsbefore = e2.bitrate.bsnow, e2.bitrate.tsbefore = e2.bitrate.tsnow;
                  else {
                    var n2 = e2.bitrate.tsnow - e2.bitrate.tsbefore;
                    "safari" == l.a.browserDetails.browser && (n2 /= 1e3);
                    var i2 = Math.round(8 * (e2.bitrate.bsnow - e2.bitrate.bsbefore) / n2);
                    e2.bitrate.value = i2 + " kbits/sec", e2.bitrate.bsbefore = e2.bitrate.bsnow, e2.bitrate.tsbefore = e2.bitrate.tsnow;
                  }
                }
              });
            });
          }, 1e3), "0 kbits/sec") : e2.bitrate.value : (d.warn("Getting the video bitrate unsupported by browser"), "Feature unsupported by browser");
        }, P = function(e2) {
          if (!G() && !U()) return d.warn("Invalid handle"), void e2.error("Invalid handle");
          var t2 = g.webrtcConfig;
          if (null === t2.dtmfSender || void 0 === t2.dtmfSender) {
            if (void 0 !== t2.pc && null !== t2.pc) {
              var r2 = t2.pc.getSenders().find(function(e3) {
                return e3.track && "audio" === e3.track.kind;
              });
              if (!r2) return d.warn("Invalid DTMF configuration (no audio track)"), void e2.error("Invalid DTMF configuration (no audio track)");
              t2.dtmfSender = r2.dtmf, t2.dtmfSender && (d.log("Created DTMF Sender"), t2.dtmfSender.ontonechange = function(e3) {
                d.debug("Sent DTMF tone: " + e3.tone);
              }), d.log({ "config.dtmfSender": t2.dtmfSender });
            }
            if (null === t2.dtmfSender || void 0 === t2.dtmfSender) return d.warn("Invalid DTMF configuration"), void e2.error("Invalid DTMF configuration");
          }
          var n2 = e2.dtmf;
          if (null == n2) return d.warn("Invalid DTMF parameters"), void e2.error("Invalid DTMF parameters");
          var i2 = n2.tones;
          if (null == i2) return d.warn("Invalid DTMF string"), void e2.error("Invalid DTMF string");
          var a2 = n2.duration;
          null == a2 && (a2 = 500);
          var o2 = n2.gap;
          null == o2 && (o2 = 50), d.debug("Sending DTMF string " + i2 + " (duration " + a2 + "ms, gap " + o2 + "ms)"), t2.dtmfSender.insertDTMF(i2, a2, o2);
        }, E = function(e2) {
          if (d.log("Cleaning WebRTC stuff"), G()) {
            var t2 = g.webrtcConfig;
            if (null != t2) {
              if (true === e2) {
                var r2 = { command: "hangup" };
                d.debug("Sending hangup request"), d.debug(r2), f.send(JSON.stringify(r2));
              }
              t2.remoteStream = null, t2.volume.timer && clearInterval(t2.volume.timer), t2.volume.value = null, t2.bitrate.timer && clearInterval(t2.bitrate.timer), t2.bitrate.timer = null, t2.bitrate.bsnow = null, t2.bitrate.bsbefore = null, t2.bitrate.tsnow = null, t2.bitrate.tsbefore = null, t2.bitrate.value = null;
              try {
                if (!t2.streamExternal && null !== t2.myStream && void 0 !== t2.myStream) {
                  d.log("Stopping local stream tracks");
                  var n2 = t2.myStream.getTracks();
                  for (var i2 in n2) {
                    var a2 = n2[i2];
                    d.log(a2), null != a2 && a2.stop();
                  }
                }
              } catch (e3) {
              }
              t2.streamExternal = false, t2.myStream = null;
              try {
                t2.pc.close();
              } catch (e3) {
              }
              t2.pc = null, t2.candidates = null, t2.mySdp = null, t2.remoteSdp = null, t2.iceDone = false, t2.dataChannel = null, t2.dtmfSender = null;
            }
            g.oncleanup();
          }
        }, D = function(e2, t2, r2, n2) {
          if (!G() && !U()) return d.warn("Invalid handle"), void r2.error("Invalid handle");
          var i2 = g.webrtcConfig;
          d.log("streamsDone:", n2), n2 && (d.debug("  -- Audio tracks:", n2.getAudioTracks()), d.debug("  -- Video tracks:", n2.getVideoTracks()));
          var a2 = false;
          if (i2.myStream && t2.update && !i2.streamExternal) {
            if ((!t2.update && L(t2) || t2.update && (t2.addAudio || t2.replaceAudio)) && n2.getAudioTracks() && n2.getAudioTracks().length) if (i2.myStream.addTrack(n2.getAudioTracks()[0]), t2.replaceAudio && "firefox" === l.a.browserDetails.browser) for (var o2 in d.log("Adding audio track:", n2.getAudioTracks()[0]), i2.pc.getSenders()) {
              var s2 = i2.pc.getSenders()[o2];
              s2 && s2.track && "audio" === s2.track.kind && s2.replaceTrack(n2.getAudioTracks()[0]);
            }
            else d.log((t2.replaceAudio ? "Replacing" : "Adding") + " audio track:", n2.getAudioTracks()[0]), i2.pc.addTrack(n2.getAudioTracks()[0], n2);
          } else i2.myStream = n2, a2 = true;
          if (!i2.pc) {
            var c2 = { iceServers: r2.iceServers, iceTransportPolicy: void 0, bundlePolicy: "balanced" }, u2 = { optional: [{ DtlsSrtpKeyAgreement: true }] };
            if (r2.rtcConstraints && "object" === p(r2.rtcConstraints)) for (var f2 in d.debug("Adding custom PeerConnection constraints:", r2.rtcConstraints), r2.rtcConstraints) u2.optional.push(r2.rtcConstraints[f2]);
            "edge" === l.a.browserDetails.browser && (c2.bundlePolicy = "max-bundle"), d.log("Creating PeerConnection"), d.debug(u2), d.log("new RTCPeerConnection" + JSON.stringify({ iceServers: c2.iceServers, pc_constraints: u2 })), i2.pc = new RTCPeerConnection(c2, u2), d.log("This is the peer connection created " + JSON.stringify(i2.pc)), i2.pc.getStats && (i2.volume.value = 0, i2.bitrate.value = "0 kbits/sec"), d.log("Preparing local SDP and gathering candidates (trickle=" + i2.trickle + ")"), i2.pc.oniceconnectionstatechange = function() {
              i2.pc && g.iceState(i2.pc.iceConnectionState);
            }, i2.pc.onicecandidate = function(e3) {
              if (null == e3.candidate || "edge" === l.a.browserDetails.browser && e3.candidate.candidate.indexOf("endOfCandidates") > 0) d.log("End of candidates."), i2.iceDone = true, true === i2.trickle ? x(r2, { completed: true }) : function(e4) {
                if (G() || U()) {
                  var t4 = g.webrtcConfig;
                  d.log("Sending offer/answer SDP..."), null !== t4.mySdp && void 0 !== t4.mySdp ? (t4.mySdp = { type: t4.pc.localDescription.type, sdp: t4.pc.localDescription.sdp }, false === t4.trickle && (t4.mySdp.trickle = false), d.debug(e4), t4.sdpSent = true, e4.success(t4.mySdp)) : d.warn("Local SDP instance is invalid, not sending anything...");
                } else d.warn("Invalid handle, not sending anything");
              }(r2);
              else {
                var t3 = { candidate: e3.candidate.candidate, sdpMid: e3.candidate.sdpMid, sdpMLineIndex: e3.candidate.sdpMLineIndex };
                true === i2.trickle && x(r2, t3);
              }
            }, i2.pc.ontrack = function(e3) {
              d.log("Handling Remote Track"), d.debug(e3), e3.streams && (i2.remoteStream = e3.streams[0], g.onremotestream(i2.remoteStream), e3.track && !e3.track.onended && (d.log("Adding onended callback to track:", e3.track), e3.track.onended = function(e4) {
                d.log("Remote track removed:", e4), i2.remoteStream && (i2.remoteStream.removeTrack(e4.target), g.onremotestream(i2.remoteStream));
              }));
            };
          }
          a2 && null != n2 && (d.log("Adding local stream"), n2.getTracks().forEach(function(e3) {
            i2.pc.addTrack(e3, n2);
          })), i2.myStream && g.onlocalstream(i2.myStream), null == e2 ? function(e3, t3) {
            if (!G() && !U()) return d.warn("Invalid handle"), void t3.error("Invalid handle");
            var r3 = g.webrtcConfig, n3 = true === t3.simulcast;
            n3 ? d.log("Creating offer (iceDone=" + r3.iceDone + ", simulcast=" + n3 + ")") : d.log("Creating offer (iceDone=" + r3.iceDone + ")");
            var i3 = { offerToReceiveAudio: j(e3) };
            true === t3.iceRestart && (i3.iceRestart = true), d.log(i3), r3.pc.createOffer(function(e4) {
              if (d.debug(e4), d.log("Setting local description"), r3.mySdp = e4.sdp, r3.pc.setLocalDescription(e4), r3.mediaConstraints = i3, r3.iceDone || r3.trickle) {
                d.log("Offer ready"), d.debug(t3);
                var n4 = { type: e4.type, sdp: e4.sdp };
                t3.success(n4);
              } else d.log("Waiting for all candidates...");
            }, t3.error, i3);
          }(t2, r2) : i2.pc.setRemoteDescription(new RTCSessionDescription(e2), function() {
            if (d.log("Remote description accepted!"), i2.remoteSdp = e2.sdp, i2.candidates && i2.candidates.length > 0) {
              for (var n3 in i2.candidates) {
                var a3 = i2.candidates[n3];
                d.debug("Adding remote candidate:", a3), a3 && true !== a3.completed ? i2.pc.addIceCandidate(new RTCIceCandidate(a3)) : i2.pc.addIceCandidate();
              }
              i2.candidates = [];
            }
            !function(e3, t3) {
              if (!G() && !U()) return d.warn("Invalid handle"), void t3.error("Invalid handle");
              var r3 = g.webrtcConfig, n4 = true === t3.simulcast;
              n4 ? d.log("Creating answer (iceDone=" + r3.iceDone + ", simulcast=" + n4 + ")") : d.log("Creating answer (iceDone=" + r3.iceDone + ")");
              var i3 = null;
              i3 = "firefox" == l.a.browserDetails.browser || "edge" == l.a.browserDetails.browser ? { offerToReceiveAudio: j(e3) } : { mandatory: { OfferToReceiveAudio: j(e3) } }, d.debug(i3), r3.pc.createAnswer(function(e4) {
                if (d.debug(e4), d.log("Setting local description"), r3.mySdp = e4.sdp, r3.pc.setLocalDescription(e4), r3.mediaConstraints = i3, r3.iceDone || r3.trickle) {
                  var n5 = { type: e4.type, sdp: e4.sdp };
                  t3.success(n5);
                } else d.log("Waiting for all candidates...");
              }, t3.error, i3);
            }(t2, r2);
          }, r2.error);
        }, x = function(e2, t2) {
          if (h) {
            if (!G() && !U()) return d.warn("Invalid handle"), void e2.error("Invalid handle");
            var r2 = { command: "trickle", candidate: t2 };
            d.vdebug("Sending trickle candidate"), d.vdebug(r2), f.send(JSON.stringify(r2));
          } else d.warn("Is the gateway down? (connected=false)");
        }, _ = function() {
          if (!G() && !U()) return d.warn("Invalid handle"), true;
          var e2 = g.webrtcConfig;
          return null === e2.pc || void 0 === e2.pc ? (d.warn("Invalid PeerConnection"), true) : void 0 === e2.myStream || null === e2.myStream ? (d.warn("Invalid local MediaStream"), true) : null === e2.myStream.getAudioTracks() || void 0 === e2.myStream.getAudioTracks() || 0 === e2.myStream.getAudioTracks().length ? (d.warn("No audio track"), true) : !e2.myStream.getAudioTracks()[0].enabled;
        }, M = function(e2) {
          if (!G() && !U()) return d.warn("Invalid handle"), false;
          var t2 = g.webrtcConfig;
          return null === t2.pc || void 0 === t2.pc ? (d.warn("Invalid PeerConnection"), false) : void 0 === t2.myStream || null === t2.myStream ? (d.warn("Invalid local MediaStream"), false) : null === t2.myStream.getAudioTracks() || void 0 === t2.myStream.getAudioTracks() || 0 === t2.myStream.getAudioTracks().length ? (d.warn("No audio track"), false) : (d.log({ "config.myStream.getAudioTracks()[0].enabled": t2.myStream.getAudioTracks()[0].enabled }), t2.myStream.getAudioTracks()[0].enabled = !e2, true);
        }, O = function() {
          if (!G() && !U()) return d.warn("Invalid handle"), false;
          var e2 = g.webrtcConfig;
          return e2.pc.getStats && "chrome" == l.a.browserDetails.browser ? null === e2.remoteStream || void 0 === e2.remoteStream ? (d.warn("Remote stream unavailable"), 0) : null === e2.volume.timer || void 0 === e2.volume.timer ? (d.log("Starting volume monitor"), e2.volume.timer = setInterval(function() {
            e2.pc.getStats(function(t2) {
              for (var r2 = t2.result(), n2 = 0; n2 < r2.length; n2++) {
                var i2 = r2[n2];
                "ssrc" == i2.type && i2.stat("audioOutputLevel") && (e2.volume.value = i2.stat("audioOutputLevel"));
              }
            });
          }, 200), 0) : e2.volume.value : (d.log("Getting the remote volume unsupported by browser"), 0);
        }, I = function() {
          var e2 = function() {
            f.removeEventListener("message", t2), f.removeEventListener("error", r2), v && clearTimeout(v), f.close();
          }, t2 = function() {
            d.log("websocket closed successfully"), e2();
          }, r2 = function() {
            d.log("closing websocket on error"), e2();
          };
          m("closed"), 1 == f.readyState ? (f.addEventListener("message", t2), f.addEventListener("error", r2), f.send(JSON.stringify({ command: "destroy" }))) : r2();
        }, L = function(e2) {
          return d.debug("isAudioSendEnabled:", e2), null == e2 || false !== e2.audio && (void 0 === e2.audioSend || null === e2.audioSend || true === e2.audioSend);
        }, A = function(e2) {
          return d.debug("isAudioSendRequired:", e2), null != e2 && (false !== e2.audio && false !== e2.audioSend && (void 0 !== e2.failIfNoAudio && null !== e2.failIfNoAudio && true === e2.failIfNoAudio));
        }, j = function(e2) {
          return d.debug("isAudioRecvEnabled:", e2), null == e2 || false !== e2.audio && (void 0 === e2.audioRecv || null === e2.audioRecv || true === e2.audioRecv);
        }, N = function e2() {
          if (h) {
            v = setTimeout(e2, 3e4);
            d.log("keepalive"), f.send(JSON.stringify({ command: "keepalive" }));
          }
        }, G = function() {
          var e2 = false;
          return g && (e2 = true), e2;
        }, U = function() {
          var e2 = false;
          return g.webrtcConfig && (e2 = true), e2;
        };
        function F(e2, t2, r2, n2, i2, a2, o2) {
          try {
            var s2 = e2[a2](o2), c2 = s2.value;
          } catch (e3) {
            return void r2(e3);
          }
          s2.done ? t2(c2) : Promise.resolve(c2).then(n2, i2);
        }
        var J = function() {
          var e2, t2 = (e2 = regeneratorRuntime.mark(function e3(t3, r2) {
            return regeneratorRuntime.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  return e4.abrupt("return", new Promise(function(e5, n2) {
                    J.server = new WebSocket(t3.server, ["at-protocol", t3.capabilityToken]), J.server.onopen = function() {
                      var t4, n3;
                      d.log("Sending initial request to Africa's Talking APIs "), t4 = r2, n3 = J.server, f = n3, m = t4.emitEvent, S = function() {
                        d.error("AfricasTalking Client Error: error occured on session creation"), I();
                      }, y = function() {
                        d.log("Creating Session... ");
                        var e6 = { webrtcConfig: { started: false, myStream: null, streamExternal: false, remoteStream: null, mySdp: null, mediaConstraints: null, pc: null, dataChannel: null, dtmfSender: null, trickle: true, iceDone: false, volume: { value: null, timer: null }, bitrate: { value: null, bsnow: null, bsbefore: null, tsnow: null, tsbefore: null, timer: null } }, consentDialog: t4.consentDialog, iceState: t4.iceState, mediaState: t4.mediaState, webrtcState: t4.webrtcState, slowLink: t4.slowLink, onmessage: t4.onmessage, onlocalstream: t4.onlocalstream, onremotestream: t4.onremotestream, ondata: t4.ondata, ondataopen: t4.ondataopen, oncleanup: t4.oncleanup, getVolume: function() {
                          return O();
                        }, isAudioMuted: function() {
                          return _();
                        }, muteAudio: function() {
                          return M(true);
                        }, unmuteAudio: function() {
                          return M(false);
                        }, getBitrate: function() {
                          return R();
                        }, send: function(e7) {
                          T(e7);
                        }, data: function(e7) {
                          b(e7);
                        }, dtmf: function(e7) {
                          P(e7);
                        }, createOffer: function(e7) {
                          k(e7);
                        }, createAnswer: function(e7) {
                          k(e7);
                        }, handleRemoteJsep: function(e7) {
                          w(e7);
                        }, hangup: function(e7) {
                          E(true === e7);
                        } };
                        d.log({ "my handle is": e6 }), v = setTimeout(N, 3e4), h = true, g = e6, t4.setHandle(e6);
                        var r3 = ["iPad", "iPhone", "iPod"].indexOf(navigator.platform) >= 0;
                        window.addEventListener(r3 ? "pagehide" : "unload", function() {
                          f.close();
                        });
                      }, e5(J.server);
                    }, J.server.onmessage = function(t4) {
                      d.log("Got this message from the websocket: " + t4.data), C(JSON.parse(t4.data)), e5(J.server);
                    }, J.server.onclose = function(t4) {
                      d.log("Lost connection to the gateway (is it down?)" + JSON.stringify(t4)), I(), e5(J.server);
                    }, J.server.onerror = function(e6) {
                      d.error("AfricasTalking Client Error: Error connecting to the Africastalking WebSockets server... " + JSON.stringify(e6)), n2(e6);
                    };
                  }));
                case 1:
                case "end":
                  return e4.stop();
              }
            }, e3);
          }), function() {
            var t3 = this, r2 = arguments;
            return new Promise(function(n2, i2) {
              var a2 = e2.apply(t3, r2);
              function o2(e3) {
                F(a2, n2, i2, o2, s2, "next", e3);
              }
              function s2(e3) {
                F(a2, n2, i2, o2, s2, "throw", e3);
              }
              o2(void 0);
            });
          });
          return function(e3, r2) {
            return t2.apply(this, arguments);
          };
        }();
        function z(e2) {
          if (d.log("Library initialized: " + e2), d.log("Using WebSockets to contact Africastalking: " + e2.server), null === e2.capabilityToken || void 0 === e2.capabilityToken) return e2.error("No capability token specified"), {};
          d.log({ gatewayCallbacks: e2 });
          var t2 = { server: e2.server, capabilityToken: e2.capabilityToken }, r2 = { setHandle: e2.setHandle, emitEvent: e2.emitEvent, destroyed: e2.destroyed, error: e2.error, oncleanup: e2.oncleanup, onlocalstream: e2.onlocalstream, onmessage: e2.onmessage, onremotestream: e2.onremotestream, consentDialog: function() {
          }, mediaState: function() {
          }, webrtcState: function() {
          }, slowLink: function() {
          }, iceState: function() {
          } };
          J(t2, r2).then(function(e3) {
            e3.send(JSON.stringify({ command: "create" }));
          }).catch(function(e3) {
            d.log("websocket Error: " + JSON.stringify(e3));
          });
        }
        z.noop = function() {
        }, z.isWebrtcSupported = function() {
          return void 0 !== window.RTCPeerConnection && null !== window.RTCPeerConnection && void 0 !== navigator.getUserMedia && null !== navigator.getUserMedia;
        };
        var V = z, B = {}, W = function(e2) {
          navigator.mediaDevices && navigator.mediaDevices.enumerateDevices && (navigator.enumerateDevices = function(e3) {
            navigator.mediaDevices.enumerateDevices().then(e3);
          });
          var t2 = [], r2 = "https:" === location.protocol, n2 = false;
          ("undefined" != typeof MediaStreamTrack && "getSources" in MediaStreamTrack || navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) && (n2 = true);
          var i2, a2 = false, o2 = false;
          i2 = function() {
            B = { audio: a2, audioCap: o2 }, d.log({ supportedDevices: B }), e2();
          }, d.log({ "finding supported devices": navigator.enumerateDevices, "some if statememt": navigator.mediaDevices, navigator }), n2 ? (!navigator.enumerateDevices && window.MediaStreamTrack && window.MediaStreamTrack.getSources && (navigator.enumerateDevices = window.MediaStreamTrack.getSources.bind(window.MediaStreamTrack)), !navigator.enumerateDevices && navigator.enumerateDevices && (navigator.enumerateDevices = navigator.enumerateDevices.bind(navigator)), navigator.enumerateDevices ? (t2 = [], navigator.enumerateDevices(function(e3) {
            e3.forEach(function(e4) {
              var n3, i3 = {};
              for (var s2 in e4) i3[s2] = e4[s2];
              "audio" === i3.kind && (i3.kind = "audioinput"), t2.forEach(function(e5) {
                e5.id === i3.id && e5.kind === i3.kind && (n3 = true);
              }), n3 || (i3.deviceId || (i3.deviceId = i3.id), i3.id || (i3.id = i3.deviceId), i3.label ? "audioinput" !== i3.kind || o2 || (o2 = true) : (i3.label = "Please invoke getUserMedia once.", r2 || (i3.label = "HTTPs is required to get label of this " + i3.kind + " device.")), "audioinput" === i3.kind && (a2 = true), t2.push(i3));
            }), i2 && i2();
          })) : i2 && i2()) : d.log("cant enumerate devices");
        };
        function q(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2++) {
            var n2 = t2[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
          }
        }
        function H(e2, t2) {
          if (!(e2 instanceof t2)) throw new TypeError("Cannot call a class as a function");
        }
        function K(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2++) {
            var n2 = t2[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
          }
        }
        var Y, $, X, Q, Z, ee, te = new (function() {
          function e2() {
            !function(e3, t3) {
              if (!(e3 instanceof t3)) throw new TypeError("Cannot call a class as a function");
            }(this, e2), this.events = {};
          }
          var t2, r2, n2;
          return t2 = e2, (r2 = [{ key: "subscribe", value: function(e3, t3) {
            var r3 = this;
            return this.events[e3] || (this.events[e3] = []), this.events[e3].push(t3), function() {
              r3.events[e3] = r3.events[e3].filter(function(e4) {
                return t3 !== e4;
              });
            };
          } }, { key: "emit", value: function(e3, t3) {
            var r3 = this.events[e3];
            r3 && r3.forEach(function(e4) {
              e4.call(null, t3);
            });
          } }, { key: "unsubscribe", value: function(e3) {
            var t3 = this.events[e3];
            return this.events[e3] || (this.events[e3] = []), t3 && this.events.splice(t3), this;
          } }, { key: "unsubscribeAll", value: function() {
            return this.events = {}, this;
          } }]) && q(t2.prototype, r2), n2 && q(t2, n2), e2;
        }())(), re = false, ne = function() {
          function e2(t3) {
            var r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            H(this, e2);
            var n3 = r3.iceServers, i2 = void 0 === n3 ? [] : n3, a2 = r3.sounds, o2 = void 0 === a2 ? {} : a2;
            this.token = t3, this.initDone = false, this.iceServers, this.atwebsocketUrl = "wss://webrtc.africastalking.com/connect", Array.isArray(i2) && i2.length > 0 && (this.iceServers = de(i2));
            var s2 = ce(o2);
            Z = new Audio(s2.ringing), ee = new Audio(s2.dialing), d.log({ ringing: Z, dialing: ee }), d.log({ iceServers: this.iceServers }), ie.bind(this)();
          }
          var t2, r2, n2;
          return t2 = e2, (r2 = [{ key: "on", value: function(e3, t3) {
            te.subscribe(e3, t3);
          } }, { key: "logout", value: function() {
            Y && Y.send({ message: { request: "unregister" } });
          } }, { key: "hold", value: function() {
            Y && Y.send({ message: { request: "hold" } });
          } }, { key: "unhold", value: function() {
            Y && Y.send({ message: { request: "unhold" } });
          } }, { key: "call", value: function(e3) {
            ee.play();
            var t3 = this.iceServers;
            W(function() {
              Y.createOffer({ iceServers: t3, media: { audioSend: true, audioRecv: true }, success: function(t4) {
                d.debug("Got SDP!"), d.debug(t4), d.log({ to: e3, jsep: t4 });
                var r3 = { request: "call", to: e3 };
                Y.send({ message: r3, jsep: t4 }), Q = e3;
              }, error: function(e4) {
                d.error("AfricasTalking Client Error: ", e4);
              } });
            });
          } }, { key: "answer", value: function() {
            var e3 = this.iceServers;
            $ = null, W(function() {
              Y.createAnswer({ jsep: X, iceServers: e3, media: { audio: true }, success: function(e4) {
                d.debug("Got SDP! audio=true, video=true"), d.debug(e4), Y.send({ message: { request: "accept" }, jsep: e4 });
              }, error: function(e4) {
                d.error("AfricasTalking Client Error: ", e4), Y.send({ message: { request: "decline", code: 480 } });
              } });
            });
          } }, { key: "dtmf", value: function(e3) {
            Y.dtmf({ dtmf: { tones: e3 } });
          } }, { key: "muteAudio", value: function() {
            return Y.muteAudio();
          } }, { key: "unmuteAudio", value: function() {
            return Y.unmuteAudio();
          } }, { key: "getVolume", value: function() {
            return Y.getVolume();
          } }, { key: "isAudioMuted", value: function() {
            return Y.isMuted();
          } }, { key: "hangup", value: function() {
            $ ? oe() : (Y.send({ message: { request: "hangup" } }), Y.hangup());
          } }, { key: "getCounterpartNum", value: function() {
            return Q;
          } }]) && K(t2.prototype, r2), n2 && K(t2, n2), e2;
        }();
        function ie() {
          var e2 = document.getElementById("remote-stream-audio");
          Y ? ae() : true !== this.initDone && (d.log("creating remoteStreamAudio", e2, Z, ee), e2 || ((e2 = document.createElement("audio")).id = "remote-stream-audio", e2.autoplay = true, document.body.appendChild(e2)), Z.loop = true, ee.loop = true, this.initDone = true, V.isWebrtcSupported() ? new V({ server: this.atwebsocketUrl, capabilityToken: this.token, setHandle: function(e3) {
            Y = e3, W(function() {
              ae();
            });
          }, onmessage: function(e3, t2) {
            d.log(" ::: Got a message :::"), d.log(JSON.stringify(e3));
            var r2 = e3.error;
            if (null == r2 || null == r2) {
              var n2 = e3.result;
              if (d.log("This is the result " + n2.toString), null != n2 && void 0 !== n2.event && null !== n2.event) {
                var i2 = n2.event;
                switch (i2) {
                  case "registration_failed":
                    return d.log("Registration failed: " + n2.code + " " + n2.reason), void ae();
                  case "registered":
                    d.log("Successfully registered as " + n2.username + "!"), re || (re = true, te.emit("ready"));
                    break;
                  case "unregistered":
                    d.log("Successfully unregistered as " + n2.username + "!"), re && (re = false, te.emit("notready"));
                    break;
                  case "calling":
                    d.log("Waiting for the peer to answer..."), te.emit("calling");
                    break;
                  case "incomingcall":
                    Q = e3.result.username.split("@")[0].split(":")[1], $ = true, Z.play(), d.log("Incoming call from " + n2.username + "!"), X = t2, te.emit("incomingcall", { from: Q });
                    break;
                  case "progress":
                    d.log("There's early media from " + n2.username + ", wairing for the call!"), null != t2 && se(t2);
                    break;
                  case "missed_call":
                    Q = e3.result.caller.split("@")[0].split(":")[1], d.log("Missed call from " + n2.caller + "!"), te.emit("missedcall", { from: Q });
                    break;
                  case "accepted":
                    ee.pause(), Z.pause(), d.log(n2.username + " accepted the call!"), null != t2 && se(t2), te.emit("callaccepted");
                    break;
                  case "hangup":
                    $ = null, ee.pause(), Z.pause(), d.log("Call hung up (" + n2.code + " " + n2.reason + ")!"), Y.hangup(), te.emit("hangup", { code: n2.code, reason: n2.reason });
                    break;
                  case "decline":
                    $ = null, ee.pause(), Z.pause(), d.log("Call declined!"), Y.hangup(), te.emit("hangup");
                    break;
                  default:
                    d.log("Received random json request " + i2.toString);
                }
              }
            } else re ? (ee.pause(), Z.pause(), Y.hangup()) : d.log("User is not registered" + r2);
          }, emitEvent: function(e3) {
            te.emit(e3);
          }, onlocalstream: function(e3) {
            d.log(" ::: Got a local stream :::"), d.log(JSON.stringify(e3));
          }, onremotestream: function(t2) {
            d.debug(" ::: Got a remote stream :::"), d.debug(JSON.stringify(t2));
            var r2 = t2.getAudioTracks();
            !function(e3, t3) {
              "chrome" === l.a.browserDetails.browser ? l.a.browserDetails.version >= 43 ? e3.srcObject = t3 : void 0 !== e3.src ? e3.src = URL.createObjectURL(t3) : d.error("AfricasTalking Client Error: Error attaching media stream to element") : e3.srcObject = t3;
            }(e2, new MediaStream(r2));
          }, oncleanup: function() {
            d.log(" ::: Got a cleanup notification :::");
          }, error: function(e3) {
            false, re = false, d.error("Africastalking Client Error: " + e3), te.unsubscribeAll();
          }, destroyed: function() {
            false, re = false, te.unsubscribeAll();
          } }) : d.error("AfricasTalking Client Error: No WebRTC support"));
        }
        var ae = function() {
          if (Y) {
            d.log({ "loggin in with handle in client": Y }), Y.send({ message: { request: "register" } });
          } else d.error("Africastalking error: Unable to initialize");
        }, oe = function() {
          $ = null;
          Y.send({ message: { request: "decline" } });
        }, se = function(e2) {
          Y.handleRemoteJsep({ jsep: e2, error: function() {
            Y.send({ message: { request: "hangup" } }), Y.hangup();
          } });
        }, ce = function(e2) {
          return { dialing: e2.dialing ? e2.dialing : "https://res.cloudinary.com/at-voice/video/upload/v1558426588/AT-voice-client-sdk/dialing_g4tn6r.mp3", ringing: e2.ringing ? e2.ringing : "https://res.cloudinary.com/at-voice/video/upload/v1558426103/AT-voice-client-sdk/ringing_au0d1x.mp3" };
        }, de = function(e2) {
          var t2 = [];
          return e2.forEach(function(e3) {
            if ("string" == typeof e3.urls && e3.urls.startsWith("stun:")) t2.push({ urls: e3.urls });
            else if ("string" == typeof e3.urls && (e3.urls.startsWith("turn:") || e3.urls.startsWith("turns:"))) t2.push({ urls: e3.urls, username: e3.username, credential: e3.credential });
            else if (Array.isArray(e3.urls)) {
              var r2 = e3.urls.filter(function(e4) {
                return "string" == typeof e4 && (e4.startsWith("turn:") || e4.startsWith("turns:"));
              });
              r2.length === e3.urls.length ? t2.push({ urls: r2, username: e3.username, credential: e3.credential }) : d.error("AfricasTalking Client Error: Invalid iceServer param ".concat(JSON.stringify(e3)));
            } else d.error("AfricasTalking Client Error: Invalid iceServer param ".concat(JSON.stringify(e3)));
          }), t2;
        }, ue = ne;
        t.default = { Client: ue };
      }]).default;
    });
  }
});
export default require_africastalking();
//# sourceMappingURL=africastalking-client.js.map
